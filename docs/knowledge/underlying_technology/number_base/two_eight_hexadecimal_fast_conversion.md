---
title: 二八十六进制快速转换
createTime: 2025/12/26 14:16:24
---

## 为什么需要==快速转换==

在实际工程中, 我们很少真的在**十进制↔二进制**之间来回计算.

更常见的情况是:

* 查看内存/寄存器/二进制数据.
* 调试程序/分析协议/阅读日志.
* 在二进制/八进制/十六进制之间切换表示.

如果每次都使用==位权展开==或==除基取余==, 效率极低.

> 好消息是: **二进制/八进制/十六进制之间存在天然的位对齐关系**.

这使得它们之间可以进行==无需计算的快速转换==.

## 二进制与八进制的关系

### 位数映射关系

* 八进制的基数是$8 = 2^3$
* 因此: **1 位八进制 = 3 位二进制**

这意味着, 八进制中的每一位, 都可以被精确拆分为 3 位二进制.

### 二进制 → 八进制

转换规则:

1. 从右向左, 每**3 位二进制**分为一组.
2. 不足 3 位时, 在高位补 0.
3. 每一组单独转换为八进制.

示例:

$$
101010_2
$$

分组:

$$
101 010
$$

对应八进制:

$$
\begin{aligned}
101_2 &= 5_8 \\
010_2 &= 2_8 \\
\end{aligned}
$$

最终结果:

$$
52_8
$$

### 八进制 → 二进制

规则正好相反:

* 每一位八进制, 直接替换为 3 位二进制.

示例:

$$
52_8
$$

展开为:

$$
\begin{aligned}
5 &\to 101 \\
2 &\to 010 \\
\end{aligned}
$$

结果:

$$
101010_2
$$

## 二进制与十六进制的关系

### 位数映射关系

* 十六进制的基数是$16 = 2^4$
* 因此: **1 位十六进制 = 4 位二进制**

这也是十六进制在计算机系统中被大量使用的根本原因.

### 二进制 → 十六进制

转换规则:

1. 从右向左, 每 **4 位二进制** 分为一组.
2. 不足 4 位时, 在高位补 0.
3. 每一组直接转换为十六进制.

示例:

$$
101010_2
$$

分组:

$$
0010 1010
$$

转换:

$$
\begin{aligned}
0010_2 &= 2_{16} \\
1010_2 &= A_{16} \\
\end{aligned}
$$

结果:

$$
2A_{16}
$$

### 十六进制 → 二进制

规则同样简单:

* 每一位十六进制, 直接替换为 4 位二进制.

示例:

$$
2A_{16}
$$

展开为：

$$
\begin{aligned}
2 &\to 0010 \\
A &\to 1010 \\
\end{aligned}
$$

结果:

$$
101010_2
$$

## 为什么这种转换一定正确

这种==分组替换==的方法, 并不是技巧, 而是数学必然.

原因在于:

* 八进制和十六进制的基数, 本身就是 2 的整数次幂.
* 位权可以被整齐地拆分或合并.

例如:

$$
\begin{aligned}
2^6 &= 8^2 \\
2^8 &= 16^2 \\
\end{aligned}
$$

> 位权不发生冲突, 数值自然保持不变.

## 工程实践中的常见形式

在实际代码和文档中, 通常使用以下表示方式:

* 二进制: `0b101010`
* 八进制: `0o52`
* 十六进制: `0x2A`

十六进制最常见, 因为它:

* 长度短.
* 可读性强.
* 与字节/内存边界天然对齐.
