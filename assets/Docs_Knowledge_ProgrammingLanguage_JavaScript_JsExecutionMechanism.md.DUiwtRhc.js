import{_ as o,C as E,c as k,o as n,a6 as t,b as p,j as a,w as i,a as e,G as r,a7 as h}from"./chunks/framework.ClVMjeck.js";const d="/assets/72c5656c1e15a695fb3a3a96ec3381cd2487fb2e.CUZZLtOu.png",B=JSON.parse('{"title":"JS执行机制","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md","filePath":"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md","lastUpdated":1742722027000}'),c={name:"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md"};function g(m,s,u,b,y,F){const l=E("Mermaid");return n(),k("div",null,[s[2]||(s[2]=t(`<h1 id="js执行机制" tabindex="-1">JS执行机制 <a class="header-anchor" href="#js执行机制" aria-label="Permalink to &quot;JS执行机制&quot;">​</a></h1><h2 id="经典面试题" tabindex="-1">经典面试题 <a class="header-anchor" href="#经典面试题" aria-label="Permalink to &quot;经典面试题&quot;">​</a></h2><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 问:输出的顺序是什么</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答1, 3, 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>延时了1秒钟, 所以是132, 合理</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 问:输出的顺序是什么</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答1, 3, 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>为什么延时0秒, 不应该是立即执行么, 怎么还是132?</p><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><p>JavaScript语言的一大特点就是<strong>单线程</strong>, 也就是说, <strong>同一时间只能做一件事</strong></p><p>:::note 这是因为JavaScript这门脚本语言诞生的使命所致的</p><p>JavaScript是为处理页面中用户的交互, 以及操作DOM而诞生的.比如我们对某个DOM元素进行添加和删除操作, 不能同时进行.应该先添加, 之后再删除</p><p>单线程就意味着, 所有任务需要排队, 前一个任务结束, 才会执行后一个任务.这样所导致的问题是:</p><p>如果JS执行的时间过长, 就会造成页面渲染不连贯, 导致页面渲染加载堵塞感</p><p>为了解决这个问题, 利用多核CPU的算力, Html5提出Web Worker标准, 运行JavaScript脚本创建多个线程.于是, JS中出现了<strong>同步</strong>和<strong>异步</strong> :::</p><h3 id="同步" tabindex="-1">同步 <a class="header-anchor" href="#同步" aria-label="Permalink to &quot;同步&quot;">​</a></h3><p>前一个任务结束后再执行后一个任务, 程序的执行顺序与任务的排队顺序是一致的, 同步的.举个例子</p><p>洗米花费5分钟, 煮饭花费40分钟, 饭熟了才去切菜花费5分钟, 炒菜花费30分钟, 一共花费了1个小时30分钟.看不懂?上图!</p>`,16)),(n(),p(h,null,{default:i(()=>[r(l,{id:"mermaid-44",class:"mermaid",graph:"flowchart%20TD%3B%E6%B4%97%E7%B1%B35%E5%88%86%E9%92%9F%20--%3E%20%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E5%88%87%E8%8F%9C5%E5%88%86%E9%92%9F%20--%3E%20%E7%82%92%E8%8F%9C30%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A11%E5%B0%8F%E6%97%B620%E5%88%86%E9%92%9F%0A"})]),fallback:i(()=>[...s[0]||(s[0]=[e(" Loading... ",-1)])]),_:1})),s[3]||(s[3]=a("h3",{id:"异步",tabindex:"-1"},[e("异步 "),a("a",{class:"header-anchor",href:"#异步","aria-label":'Permalink to "异步"'},"​")],-1)),s[4]||(s[4]=a("p",null,"你在做一件事情时, 因为这件事情会花费很长时间, 在做这件事的同时, 可以去处理其他事情.举个例子",-1)),s[5]||(s[5]=a("p",null,"洗米花费5分钟, 煮饭花费40小时, 饭还有35分钟熟的时候, 去切菜花费5分钟, 炒菜花费30分钟, 这时饭刚好熟了, 一共花费了45个小时.看不懂?上图!",-1)),(n(),p(h,null,{default:i(()=>[r(l,{id:"mermaid-54",class:"mermaid",graph:"flowchart%20TD%3B%E6%B4%97%E7%B1%B35%E5%88%86%E9%92%9F%20--%3E%20%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A145%E5%88%86%E9%92%9F%3B%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E5%88%87%E8%8F%9C5%E5%88%86%E9%92%9F%20--%3E%20%E7%82%92%E8%8F%9C30%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A145%E5%88%86%E9%92%9F%0A"})]),fallback:i(()=>[...s[1]||(s[1]=[e(" Loading... ",-1)])]),_:1})),s[6]||(s[6]=t('<h3 id="本质" tabindex="-1">本质 <a class="header-anchor" href="#本质" aria-label="Permalink to &quot;本质&quot;">​</a></h3><p>同步和异步本质就是执行顺序的不同</p><h3 id="同步任务" tabindex="-1">同步任务 <a class="header-anchor" href="#同步任务" aria-label="Permalink to &quot;同步任务&quot;">​</a></h3><p>同步任务都是在主线程上执行, 形成一个<strong>执行栈</strong></p><h3 id="异步任务" tabindex="-1">异步任务 <a class="header-anchor" href="#异步任务" aria-label="Permalink to &quot;异步任务&quot;">​</a></h3><p>JS的异步是通过回调函数实现的</p><p>一般而言, 异步任务有以下3种类型</p><ol><li>普通事件, 如<code>click</code>, <code>resize</code>等</li><li>资源加载, 如<code>load</code>, <code>error</code>等</li><li>定时器, 包括<code>setInterval</code>, <code>setTimeout</code>等</li></ol><p>异步任务相关添加到<strong>任务队列</strong>中(任务队列也称为<strong>消息队列</strong>)</p><h2 id="机制" tabindex="-1">机制 <a class="header-anchor" href="#机制" aria-label="Permalink to &quot;机制&quot;">​</a></h2><ol><li>先执行<strong>执行栈中的同步任务</strong><ol><li>输出<code>1</code></li><li>输出<code>3</code></li></ol></li><li>异步任务放入消息队列中 <ol><li>记录<code>setTimeout(console.log(2), 0)</code></li></ol></li><li>一旦执行栈的所有同步任务执行完毕, 系统就会按次序读取<strong>消息队列</strong>中的异步任务, 于是被读取的异步任务结束等待状态, 进入执行栈, 开始执行 <ol><li>输出<code>2</code></li></ol></li></ol><p>由于主线程不断的重复获取任务, 执行任务, 再获取任务, 再执行, 所以这种机制被称为<strong>事件循环</strong>(event loop)</p><p><img src="'+d+'" alt="72c5656c1e15a695fb3a3a96ec3381cd2487fb2e" data-fancybox="gallery" loading="lazy"></p>',13))])}const A=o(c,[["render",g]]);export{B as __pageData,A as default};
