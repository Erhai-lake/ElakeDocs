import{_ as o,c as d,o as a,a6 as c}from"./chunks/framework.Du9XbX32.js";const p="/ElakeDocs/assets/608f930e7463f9f5e05345d1b0cce34e8f45d513.OXnszvQ3.png",l="/ElakeDocs/assets/66587c1bfdca2d6c5801152253b2228d45ad161b.CdDXSj1m.png",t="/ElakeDocs/assets/a31c34e454d8d949c77244370db3716ee77b97f8.DT9MCdGd.png",r="/ElakeDocs/assets/b42194ff6cf29593275c955b50a663ef12c65fc1.D2q56faH.png",s="/ElakeDocs/assets/6bb725d2efcd2f28169e5d01f1b430c560b9d353.BYRzPpwu.png",i="/ElakeDocs/assets/1a0e2ae2d550be978173b007892e9fbd233f68e4.Dq0B7xR5.png",k=JSON.parse('{"title":"括号的作用","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/TheRoleOfBrackets.md","filePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/TheRoleOfBrackets.md","lastUpdated":1742722027000}'),n={name:"Docs/Knowledge/ProgrammingLanguage/RegularExpression/TheRoleOfBrackets.md"};function b(f,e,h,g,m,_){return a(),d("div",null,e[0]||(e[0]=[c('<h1 id="括号的作用" tabindex="-1">括号的作用 <a class="header-anchor" href="#括号的作用" aria-label="Permalink to &quot;括号的作用&quot;">​</a></h1><p>不管哪门语言中都有括号.正则表达式也是一门语言, 而括号的存在使这门语言更为强大</p><p>对括号的使用是否得心应手, 是衡量对正则的掌握水平的一个侧面标准</p><p>括号的作用, 其实三言两语就能说明白, 括号提供了分组, 便于我们引用它</p><p>引用某个分组, 会有两种情形:在JavaScript里引用它, 在正则表达式里引用它</p><p>本章内容虽相对简单, 但我也要写长点</p><h2 id="分组" tabindex="-1">分组 <a class="header-anchor" href="#分组" aria-label="Permalink to &quot;分组&quot;">​</a></h2><p>我们知道<code>/a+/</code>匹配连续出现的<code>a</code>, 而要匹配连续出现的<code>ab</code>时, 需要使用<code>/(ab)+/</code></p><p>其中括号是提供分组功能, 使量词<code>+</code>作用于<code>ab</code>这个整体</p><p><img src="'+p+'" alt="608f930e7463f9f5e05345d1b0cce34e8f45d513" data-fancybox="gallery" loading="lazy"></p><h2 id="分支结构" tabindex="-1">分支结构 <a class="header-anchor" href="#分支结构" aria-label="Permalink to &quot;分支结构&quot;">​</a></h2><p>而在多选分支结构<code>(p1|p2)</code>中, 此处括号的作用也是不言而喻的, 提供了子表达式的所有可能</p><p>比如, 要匹配如下的字符串</p><p><code>I love JavaScript</code></p><p><code>I love Java</code></p><p><img src="'+l+'" alt="66587c1bfdca2d6c5801152253b2228d45ad161b" data-fancybox="gallery" loading="lazy"></p><p>如果去掉正则中的括号, 即<code>/^I love JavaScript|Java$/</code>, 匹配字符串是<code>I love JavaScript</code>和<code>Java</code>, 当然这不是我们想要的</p><h2 id="引用分组" tabindex="-1">引用分组 <a class="header-anchor" href="#引用分组" aria-label="Permalink to &quot;引用分组&quot;">​</a></h2><p>这是括号一个重要的作用, 有了它, 我们就可以进行数据提取, 以及更强大的替换操作</p><p>而要使用它带来的好处, 必须配合使用实现环境的API</p><p>以日期为例.假设格式是yyyy-mm-dd的, 我们可以先写一个简单的正则</p><p><code>/\\d{4}-\\d{2}-\\d{2}/</code>然后再修改成括号版的<code>/(\\d{4})-(\\d{2})-(\\d{2})/</code></p><p>这时, 就可以通过<code>$1</code>, <code>$2</code>, <code>$3</code>来提取数据了</p><p><img src="'+t+'" alt="a31c34e454d8d949c77244370db3716ee77b97f8" data-fancybox="gallery" loading="lazy"></p><h2 id="反向引用" tabindex="-1">反向引用 <a class="header-anchor" href="#反向引用" aria-label="Permalink to &quot;反向引用&quot;">​</a></h2><p>除了使用相应<code>API</code>来引用分组, 也可以在正则本身里引用分组.但只能引用之前出现的分组, 即反向引用</p><p>还是以日期为例</p><p><code>2024-08-01</code></p><p><code>2024/08/01</code></p><p><code>2024.08.01</code></p><p><code>2024-08/01</code></p><p>最先可能想到的正则是<code>/\\d{4}(-|\\/|\\.)\\d{2}(-|\\/|\\.)\\d{2}/</code></p><p>其中<code>/</code>和<code>.</code>需要转义.虽然匹配了要求的情况, 但也匹配<code>2024-08/01</code>这样的数据</p><p>假设我们想要求分割符前后一致怎么办?此时需要使用反向引用</p><p><code>/\\d{4}(-|\\/|\\.)\\d{2}\\1\\d{2}/</code></p><p><img src="'+r+'" alt="b42194ff6cf29593275c955b50a663ef12c65fc1" data-fancybox="gallery" loading="lazy"></p><p>注意里面的<code>\\1</code>, 表示的引用之前的那个分组<code>(-|\\/|\\.)</code>.不管它匹配到什么(比如<code>-</code>), <code>\\1</code>都匹配那个同样的具体某个字符</p><p>我们知道了<code>\\1</code>的含义后, 那么<code>\\2</code>和<code>\\3</code>的概念也就理解了, 即分别指代第二个和第三个分组</p><p>看到这里, 此时, 恐怕你会有三个问题</p><h3 id="括号嵌套怎么办" tabindex="-1">括号嵌套怎么办? <a class="header-anchor" href="#括号嵌套怎么办" aria-label="Permalink to &quot;括号嵌套怎么办?&quot;">​</a></h3><p>以左括号(开括号)为准</p><p><code>/^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/</code></p><p><img src="'+s+'" alt="6bb725d2efcd2f28169e5d01f1b430c560b9d353" data-fancybox="gallery" loading="lazy"></p><p>我们可以看看这个正则匹配模式</p><ul><li>第一个字符是数字, 比如说<code>1</code></li><li>第二个字符是数字, 比如说<code>2</code></li><li>第三个字符是数字, 比如说<code>3</code></li><li>接下来的是<code>\\1</code>, 是第一个分组内容, 那么看第一个开括号对应的分组是什么, 是<code>123</code></li><li>接下来的是<code>\\2</code>, 找到第2个开括号, 对应的分组, 匹配的内容是<code>1</code></li><li>接下来的是<code>\\3</code>, 找到第3个开括号, 对应的分组, 匹配的内容是<code>23</code></li><li>最后的是<code>\\4</code>, 找到第3个开括号, 对应的分组, 匹配的内容是<code>3</code></li></ul><p>这个问题, 估计仔细看一下, 就该明白了</p><h3 id="_10表示什么呢" tabindex="-1">\\10表示什么呢 <a class="header-anchor" href="#_10表示什么呢" aria-label="Permalink to &quot;\\10表示什么呢&quot;">​</a></h3><p>另外一个疑问可能是, 即<code>\\10</code>是表示第10个分组, 还是<code>\\1</code>和<code>0</code>呢?</p><p>答案是前者, 虽然一个正则里出现<code>\\10</code>比较罕见</p><p><code>/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/</code></p><p><img src="'+i+'" alt="1a0e2ae2d550be978173b007892e9fbd233f68e4" data-fancybox="gallery" loading="lazy"></p><h3 id="引用不存在的分组会怎样" tabindex="-1">引用不存在的分组会怎样? <a class="header-anchor" href="#引用不存在的分组会怎样" aria-label="Permalink to &quot;引用不存在的分组会怎样?&quot;">​</a></h3><p>因为反向引用, 是引用前面的分组, 但我们在正则里引用了不存在的分组时, 此时正则不会报错, 只是匹配反向引用的字符本身.例如<code>\\2</code>, 就匹配<code>\\2</code></p><div class="warning custom-block"><p class="custom-block-title">警告</p><p><code>\\2</code>表示对<code>2</code>进行了转意</p></div><h2 id="非捕获分组" tabindex="-1">非捕获分组 <a class="header-anchor" href="#非捕获分组" aria-label="Permalink to &quot;非捕获分组&quot;">​</a></h2><p>之前文中出现的分组, 都会捕获它们匹配到的数据, 以便后续引用, 因此也称他们是捕获型分组</p><p>如果只想要括号最原始的功能, 但不会引用它.就是既不在API里引用.也不在正则里反向引用</p><p>此时可以使用非捕获分组<code>(?:p)</code>, 例如本文第一个例子可以修改为</p><p><code>/(?:ab)+/g</code></p>',59)]))}const x=o(n,[["render",b]]);export{k as __pageData,x as default};
