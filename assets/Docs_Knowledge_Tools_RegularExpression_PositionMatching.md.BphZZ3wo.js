import{_ as e,c as d,o as c,a6 as a}from"./chunks/framework.ClVMjeck.js";const t="/assets/5a0fd35ae235cf87606604655be62a9b23331738.BrOFVMn_.png",l="/assets/487d4c104afcc86af53403935cf4e007ad5a6654.BXpUi9oz.png",p="/assets/a3a41d415c158cd259a0b3d806b1c38cd82813af.BPhgKZPC.png",s="/assets/3ddfabb0ddc78d271575e4b39c867af17d28fad3.DKs9P7kY.png",i="/assets/fd1b66fbe974c35033144c10591cc7672d0921e8.bLZ7H6bP.png",r="/assets/5dedbf0b5432386b93f25bf3965940d96aa45516.CHgJUQmR.png",n="/assets/e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c.BHLplDir.png",y=JSON.parse('{"title":"位置匹配","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/Tools/RegularExpression/PositionMatching.md","filePath":"Docs/Knowledge/Tools/RegularExpression/PositionMatching.md","lastUpdated":1754243091000}'),b={name:"Docs/Knowledge/Tools/RegularExpression/PositionMatching.md"};function u(f,o,h,q,g,_){return c(),d("div",null,[...o[0]||(o[0]=[a('<h1 id="位置匹配" tabindex="-1">位置匹配 <a class="header-anchor" href="#位置匹配" aria-label="Permalink to &quot;位置匹配&quot;">​</a></h1><p>:::note 再次强调, 正则表达式是匹配模式, 要么匹配字符, 要么匹配位置.请记住这句话</p><p>然而大部分人学习正则时, 对于匹配位置的重视程度没有那么高 :::</p><h2 id="什么是位置" tabindex="-1">什么是位置 <a class="header-anchor" href="#什么是位置" aria-label="Permalink to &quot;什么是位置&quot;">​</a></h2><p>位置是相邻字符之间的位置.例如, 下图中箭头所指的地方</p><p><img src="'+t+'" alt="5a0fd35ae235cf87606604655be62a9b23331738" data-fancybox="gallery" loading="lazy"></p><h2 id="如何匹配位置" tabindex="-1">如何匹配位置 <a class="header-anchor" href="#如何匹配位置" aria-label="Permalink to &quot;如何匹配位置&quot;">​</a></h2><p>共有6个锚字符</p><p><code>^</code>, <code>$</code>, <code>\\b</code>, <code>\\B</code>, <code>(?=p)</code>, <code>(?!p)</code></p><h3 id="前两个" tabindex="-1">前两个 <a class="header-anchor" href="#前两个" aria-label="Permalink to &quot;前两个&quot;">​</a></h3><p><code>^</code>(脱字符)匹配开头, 在多行匹配中匹配行开头</p><p><code>$</code>(美元符号)匹配结尾, 在多行匹配中匹配行结尾</p><p><img src="'+l+'" alt="487d4c104afcc86af53403935cf4e007ad5a6654" data-fancybox="gallery" loading="lazy"></p><h3 id="中间两个" tabindex="-1">中间两个 <a class="header-anchor" href="#中间两个" aria-label="Permalink to &quot;中间两个&quot;">​</a></h3><p><code>\\b</code>是单词边界, 具体就是<code>\\w</code>和<code>\\W</code>之间的位置, 也包括<code>\\w</code>和<code>^</code>之间的位置, 也包括<code>\\w</code>和<code>$</code>之间的位置</p><p>比如一个文件名是<code>[JS] Demo.js</code>中的<code>\\b</code></p><p><img src="'+p+'" alt="a3a41d415c158cd259a0b3d806b1c38cd82813af" data-fancybox="gallery" loading="lazy"></p><p>为什么是这样呢?仔细看看呢~</p><p>首先, 我们知道, <code>\\w</code>是字符组<code>[0-9a-zA-Z_]</code>的简写形式, 即<code>\\w</code>是字母数字或者下划线的中任何一个字符.而<code>\\W</code>是排除字符组<code>[^0-9a-zA-Z_]</code>的简写形式, 即<code>\\W</code>是<code>\\w</code>以外的任何一个字符</p><p>此时我们可以看看<code>[#JS#] #Demo#.#js#</code>中的每一个<code>#</code>是怎么来的</p><ul><li>第一个<code>#</code>, 两边是<code>[</code>与<code>J</code>, 是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第二个<code>#</code>, 两边是<code>S</code>与<code>]</code>, 也就是<code>\\w</code>和<code>\\W</code>之间的位置</li><li>第三个<code>#</code>, 两边是空格与<code>D</code>, 也就是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第四个<code>#</code>, 两边是<code>o</code>与<code>.</code>, 也就是<code>\\w</code>和<code>\\W</code>之间的位置</li><li>第五个<code>#</code>, 两边是<code>.</code>与<code>j</code>, 也就是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第六个<code>#</code>, 其对应的位置是结尾, 但其前面的字符<code>s</code>是<code>\\w</code>, 即<code>\\w</code>和<code>$</code>之间的位置</li></ul><p>知道了<code>\\b</code>的概念后, 那么<code>\\B</code>也就相对好理解了</p><p><code>\\B</code>就是<code>\\b</code>的反面的意思.非单词边界/例如在字符串中所有位置中.扣掉<code>\\b</code>.剩下的都是<code>\\B</code>的</p><p>具体说来就是<code>\\w</code>与<code>\\w</code>, <code>\\W</code>与<code>\\W</code>, <code>^</code>与<code>\\W</code>, <code>\\W</code>与<code>$</code>之间的位置</p><p>比如上面的例子, 把所有<code>\\B</code>替换成<code>#</code></p><p><img src="'+s+'" alt="3ddfabb0ddc78d271575e4b39c867af17d28fad3" data-fancybox="gallery" loading="lazy"></p><h3 id="后两个" tabindex="-1">后两个 <a class="header-anchor" href="#后两个" aria-label="Permalink to &quot;后两个&quot;">​</a></h3><p><code>(?=p)</code>, 其中<code>p</code>是一个子模式, 即<code>p</code>前面的位置</p><p>比如<code>(?=l)</code>, 表示<code>l</code>字符前面的位置, 例如</p><p><img src="'+i+'" alt="fd1b66fbe974c35033144c10591cc7672d0921e8" data-fancybox="gallery" loading="lazy">而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思</p><p><img src="'+r+'" alt="5dedbf0b5432386b93f25bf3965940d96aa45516" data-fancybox="gallery" loading="lazy"></p><h2 id="位置的特性" tabindex="-1">位置的特性 <a class="header-anchor" href="#位置的特性" aria-label="Permalink to &quot;位置的特性&quot;">​</a></h2><p>对于位置的理解, 我们可以理解成空字符<code> &quot;&quot;</code></p><p>比如<code>&quot;hello&quot;</code>字符串等价于如下的形式</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;</code></p><p>也就是</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</code></p><p>因此, 把<code>/^hello$/</code>写成<code>/^^hello?$/</code>, 是没有任何问题的</p><p>:::note 如果你想写屎山代码, 甚至可以写成更复杂</p><p><code>/(?=he)^^he(?=\\w)llo$\\b\\b$/</code></p><p><img src="'+n+'" alt="e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c" data-fancybox="gallery" loading="lazy"> :::</p><p>也就是说字符之间的位置, 可以写成多个</p><p>把位置理解空字符, 是对位置非常有效的理解方式</p>',43)])])}const x=e(b,[["render",u]]);export{y as __pageData,x as default};
