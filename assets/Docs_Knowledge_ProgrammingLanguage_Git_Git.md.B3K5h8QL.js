import{_ as a,c as o,o as e,a6 as i}from"./chunks/framework.BQ10fS7j.js";const u=JSON.parse('{"title":"前言","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/Git/Git.md","filePath":"Docs/Knowledge/ProgrammingLanguage/Git/Git.md","lastUpdated":1742722027000}'),t={name:"Docs/Knowledge/ProgrammingLanguage/Git/Git.md"};function r(n,l,s,d,c,_){return e(),o("div",null,l[0]||(l[0]=[i('<h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p>Git是一个开源的分布式版本控制系统, 可以有效, 高速地处理从很小到非常大的项目版本管理.也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件.</p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><ol><li>备份 <ol><li>小明负责的模块就要完成了, 就在即将Release之前的一瞬间, 电脑突然蓝屏, 硬盘光荣牺牲!几个月来的努力付之东流.</li></ol></li><li>代码还原 <ol><li>这个项目中需要一个很复杂的功能, 小明摸索了一个星期终于有眉目了, 可是这被改得面目全非的代码已经回不到从前了.什么地方能买到哆啦A梦的时光机啊?</li></ol></li><li>协同开发 <ol><li>小明和小帅先后从文件服务器上下载了同一个文件:<code>Analysis.java</code>.小明在<code>Analysis.java</code>文件中声明了一个方法, 叫<code>count ()</code>, 先保存到了文件服务器上.小帅在<code>Analysis.java</code>文件中声明了一个方法, 叫<code>sum ()</code>, 也随后保存到了文件服务器上, 于是, <code>count ()</code>方法就只存在于小明的记忆中了(因为小帅是在小明写新方法前下载的).</li></ol></li><li>追溯问题 <ol><li>小美是一位项目经理, 每次因为项目进度挨骂之后, 他都不知道该扣哪个程序员的工资!就拿这次来说吧, 有个Bug调试了30多个小时才知道是因为相关属性没有在应用初始化时赋值!可是小明, 小帅都不承认是自己干的(如果有版本控制器的话, 小美就可以查看版本控制器日志, 从而知道是小明的问题).</li></ol></li></ol><p><s>小明:为什么受伤的总是我qwq</s></p><h2 id="版本控制器的方式" tabindex="-1">版本控制器的方式 <a class="header-anchor" href="#版本控制器的方式" aria-label="Permalink to &quot;版本控制器的方式&quot;">​</a></h2><p>本教程为分布式版本控制工具: Git</p><ol><li>集中式版本控制工具 <ol><li>集中式版本控制工具, 版本库是集中存放在中央服务器的, team里每个人work时从中央服务器下载代码, 是必须联网才能工作, 局域网或互联网.个人修改后然后提交到中央版本库.</li><li>举例:SVN和CVS</li></ol></li><li>分布式版本控制工具 <ol><li>分布式版本控制系统没有“中央服务器”, 每个人的电脑上都是一个完整的版本库, 这样工作的时候, 无需要联网了, 因为版本库就在你自己的电脑上.多人协作只需要各自的修改推送给对方, 就能互相看到对方的修改了. <ol><li>举例:Git</li></ol></li></ol></li></ol>',8)]))}const p=a(t,[["render",r]]);export{u as __pageData,p as default};
