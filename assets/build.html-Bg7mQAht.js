import{_ as t,c as a,e as d,o as c}from"./app-PXrWi8_d.js";const s="/assets/279caf5c12319439086d23dbe5948d47adef252e-DnmiSzuM.png",n="/assets/a5067377e2b907a5bbb80b33957fb8c135b73e24-lENsdR8P.png",o="/assets/41f451b58f75b4280337816e000ee1dec0eb2051-jTSnE6BV.png",p="/assets/ef6d26401fb989ea8ab06fa7ab96ac6b7b4d721c-C6m5DEmy.png",r="/assets/23b1e7ae90158f65204003938e37939682f1305a-YJzF4Vf3.png",l="/assets/9bd0ea4b8f8da469c2131379d6437fac38ff6722-CDbrRukI.png",i="/assets/c7f432db3324b46338af946af2a7d98f573b8aea-D65GXAoq.png",b="/assets/5b0b02b0326343840f22e3f91d4a99519995d352-BxGNdJJ6.png",f="/assets/76a70ef1d2875cabd5ffe4c451b225dd1752f63a-oUAsi1xm.png",g="/assets/600924080d818f601e3a877e819f5c6ee00b35be-pW4eKboe.png",h="/assets/03084e7233ca1842fcc6dd110e2eb85d5fc7ad51-Dj7RyxDC.png",m="/assets/d9070c5a763f18950db7756780381928c0df65be-DE7oEOEb.png",y="/assets/cce26b8d9180837d9d61e7b0ab46303be3f09df2-DjFOPlrr.png",x="/assets/94e61bc13723bd3fc792ef02b9135bceae94a3a9-D4U-FvAO.png",_="/assets/50edf82c42a5e1459c9f6037b53d9f3977a081d4-Bs0I9jAM.png",u="/assets/3cf9ea3d6d3e624bf023b57b46227d4c36edf920-D8D1-72Q.png",z="/assets/accfc60076b0044f48191966130fa9b13f7f9db7-tUWZ1i5g.png",$="/assets/9d11a76d086eeb8e9351e4ad19d77a33ba5b667a-Cmh_h61X.png",k="/assets/b1afd07a0266dff10447cbb7915f08f9adb39c9b-CQqMfZYX.png",D={};function E(A,e){return c(),a("div",null,[...e[0]||(e[0]=[d('<p>对于一门语言的掌握程度怎么样, 可以有两个角度来衡量: 读和写.</p><p>不仅要看懂别人的解决方案, 也要能独立地解决问题. 代码是这样, 正则表达式也是这样.</p><p>与读相比, 写往往更为重要, 这个道理是不言而喻的.</p><p>对正则的运用, 首重就是:如何针对问题, 构建一个合适的正则表达式?</p><h2 id="平衡法则" tabindex="-1"><a class="header-anchor" href="#平衡法则"><span>平衡法则</span></a></h2><p>构建正则有一点非常重要, 需要做到下面几点的平衡:</p><ol><li>匹配预期的字符串.</li><li>不匹配非预期的字符串.</li><li>可读性和可维护性.</li><li>效率.</li></ol><h2 id="构建正则前提" tabindex="-1"><a class="header-anchor" href="#构建正则前提"><span>构建正则前提</span></a></h2><h3 id="是否能使用正则" tabindex="-1"><a class="header-anchor" href="#是否能使用正则"><span>是否能使用正则</span></a></h3><p>正则太强大了, 以至于我们随便遇到一个操作字符串问题时, 都会下意识地去想, 用正则该怎么做.但我们始终要提醒自己, 正则虽然强大, 但不是万能的, 很多看似很简单的事情, 还是做不到的.</p><p>比如匹配这样的字符串: 1010010001....</p><p>虽然很有规律. 但是只靠正则就是无能为力.</p><h3 id="是否有必要使用正则" tabindex="-1"><a class="header-anchor" href="#是否有必要使用正则"><span>是否有必要使用正则</span></a></h3><p>要认识到正则的局限, 不要去研究根本无法完成的任务. 同时, 也不能走入另一个极端: 无所不用正则. 能用字符串API解决的简单问题, 就不该正则出马.</p><h3 id="是否有必要构建一个复杂的正则" tabindex="-1"><a class="header-anchor" href="#是否有必要构建一个复杂的正则"><span>是否有必要构建一个复杂的正则</span></a></h3><p>比如密码匹配问题, 要求密码长度6-12位, 由数字, 小写字符和大写字母组成, 但必须至少包括2种字符.</p><p><code>/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/</code>.</p><p>这个正则其实可以使用多个小正则来做:</p><p><code>/^[0-9A-Za-z]{6,12}$/</code>.</p><p><code>/^[0-9]{6,12}$/</code>.</p><p><code>/^[A-Z]{6,12}$/</code>.</p><p><code>/^[a-z]{6,12}$/</code>.</p><h2 id="准确性" tabindex="-1"><a class="header-anchor" href="#准确性"><span>准确性</span></a></h2><p>所谓准确性, 就是能匹配预期的目标, 并且不匹配非预期的目标.</p><p>这里提到了<mark>预期</mark>二字, 那么我们就需要知道目标的组成规则.</p><p>不然没法界定什么样的目标字符串是符合预期的, 什么样的又不是符合预期的.</p><p>下面将举例说明, 当目标字符串构成比较复杂时, 该如何构建正则, 并考虑到哪些平衡.</p><h3 id="匹配固定电话" tabindex="-1"><a class="header-anchor" href="#匹配固定电话"><span>匹配固定电话</span></a></h3><p>比如要匹配如下格式的固定电话号码:</p><p><code>055188888888</code>.</p><p><code>0551-88888888</code>.</p><p><code>(0551)88888888</code>.</p><p>第一步, 了解各部分的模式规则.</p><p>上面的电话, 总体上分为区号和号码两部分(不考虑分机号和+86的情形).</p><p>区号是0开头的3到4位数字, 对应的正则是: <code>0\\d{2,3}</code>.</p><p>号码是非0开头的7到8位数字, 对应的正则是: <code>[1-9]\\d{6,7}</code>.</p><p>因此, 匹配<code>055188888888</code>的正则是: <code>/^0\\d{2,3}[1-9]\\d{6,7}$/</code>.</p><p>匹配<code>0551-88888888</code>的正则是: <code>/^0\\d{2,3}-[1-9]\\d{6,7}$/</code>.</p><p>匹配<code>(0551)88888888</code>的正则是: <code>/^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/</code>.</p><p>第二步, 明确形式关系.</p><p>这三者情形是或的关系, 可以构建分支:</p><p><code>/^0\\d{2,3}[1-9]\\d{6,7}$|^0\\d{2,3}-[1-9]\\d{6,7}$|^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/</code>.</p><p>提取公共部分:</p><p><code>/^(0\\d{2,3}|0\\d{2,3}-|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/</code>.</p><p>进一步简写:</p><p><code>/^(0\\d{2,3}-?|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/</code>.</p><p>其可视化形式:</p><figure><img src="'+s+'" alt="279caf5c12319439086d23dbe5948d47adef252e" tabindex="0" loading="lazy"><figcaption>279caf5c12319439086d23dbe5948d47adef252e</figcaption></figure><p>上面的正则构建过程略显罗嗦, 但是这样做, 能保证正则是准确的.</p><p>上述三种情形是或的关系，这一点很重要，不然很容易按字符是否出现的情形把正则写成:</p><p><code>/^\\(?0\\d{2,3}\\)?-?[1-9]\\d{6,7}$/</code>.</p><p>虽然也能匹配上述目标字符串, 但也会匹配<code>(0551-88888888</code>这样的字符串. 当然, 这不是我们想要的.</p><p>其实这个正则也不是完美的, 因为现实中, 并不是每个3位数和4位数都是一个真实的区号.</p><p>这就是一个平衡取舍问题, 一般够用就行.</p><h2 id="效率" tabindex="-1"><a class="header-anchor" href="#效率"><span>效率</span></a></h2><p>保证了准确性后, 才需要是否要考虑要优化.大多数情形是不需要优化的, 除非运行的非常慢. 什么情形正则表达式运行才慢呢? 我们需要考察正则表达式的运行过程(原理).</p><p>正则表达式的运行分为如下的阶段:</p><ol><li>编译.</li><li>设定起始位置.</li><li>尝试匹配.</li><li>匹配失败的话, 从下一位开始继续第3步.</li><li>最终结果: 匹配成功或失败.</li></ol><p>匹配会出现效率问题, 主要出现在上面的第3阶段和第4阶段.</p><p>因此, 主要优化手法也是针对这两阶段的.</p><h3 id="使用具体型字符组代替通配符消除回溯" tabindex="-1"><a class="header-anchor" href="#使用具体型字符组代替通配符消除回溯"><span>使用具体型字符组代替通配符消除回溯</span></a></h3><p>而在第三阶段, 最大的问题就是回溯.</p><p>例如, 匹配双引用号之间的字符. 如, 匹配字符串123<code>abc</code>456中的<code>abc</code>.</p><p>如果正则用的是: <code>/&quot;.*&quot;/,</code>, 会在第3阶段产生4次回溯(粉色表示<code>.*</code>匹配的内容):</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+n+'" alt="a5067377e2b907a5bbb80b33957fb8c135b73e24" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+o+'" alt="41f451b58f75b4280337816e000ee1dec0eb2051" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+p+'" alt="ef6d26401fb989ea8ab06fa7ab96ac6b7b4d721c" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+r+'" alt="23b1e7ae90158f65204003938e37939682f1305a" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+l+'" alt="9bd0ea4b8f8da469c2131379d6437fac38ff6722" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+i+'" alt="c7f432db3324b46338af946af2a7d98f573b8aea" loading="lazy"></td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;"><img src="'+b+'" alt="5b0b02b0326343840f22e3f91d4a99519995d352" loading="lazy"></td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;"><img src="'+f+'" alt="76a70ef1d2875cabd5ffe4c451b225dd1752f63a" loading="lazy"></td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;"><img src="'+g+'" alt="600924080d818f601e3a877e819f5c6ee00b35be" loading="lazy"></td></tr><tr><td style="text-align:center;">10</td><td style="text-align:center;"><img src="'+h+'" alt="03084e7233ca1842fcc6dd110e2eb85d5fc7ad51" loading="lazy"></td></tr><tr><td style="text-align:center;">11</td><td style="text-align:center;"><img src="'+m+'" alt="d9070c5a763f18950db7756780381928c0df65be" loading="lazy"></td></tr><tr><td style="text-align:center;">12</td><td style="text-align:center;"><img src="'+y+'" alt="cce26b8d9180837d9d61e7b0ab46303be3f09df2" loading="lazy"></td></tr><tr><td style="text-align:center;">13</td><td style="text-align:center;"><img src="'+x+'" alt="94e61bc13723bd3fc792ef02b9135bceae94a3a9" loading="lazy"></td></tr></tbody></table><p>如果正则用的是:<code>/&quot;.*?&quot;/</code>, 会产生2次回溯(粉色表示<code>.*?</code>匹配的内容):</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+_+'" alt="50edf82c42a5e1459c9f6037b53d9f3977a081d4" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+u+'" alt="3cf9ea3d6d3e624bf023b57b46227d4c36edf920" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+z+'" alt="accfc60076b0044f48191966130fa9b13f7f9db7" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+$+'" alt="9d11a76d086eeb8e9351e4ad19d77a33ba5b667a" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+k+'" alt="b1afd07a0266dff10447cbb7915f08f9adb39c9b" loading="lazy"></td></tr></tbody></table><p>因为回溯的存在, 需要引擎保存多种可能中未尝试过的状态, 以便后续回溯时使用.注定要占用一定的内存.</p><p>此时要使用具体化的字符组. 来代替通配符<code>.</code>. 以便消除不必要的字符. 此时使用正则<code>/&quot;[^&quot;]*&quot;/</code>. 即可.</p><h3 id="使用非捕获型分组" tabindex="-1"><a class="header-anchor" href="#使用非捕获型分组"><span>使用非捕获型分组</span></a></h3><p>因为括号的作用之一是, 可以捕获分组和分支里的数据. 那么就需要内存来保存它们.</p><p>当我们不需要使用分组引用和反向引用时, 此时可以使用非捕获分组. 例如:</p><p><code>/^[+-]?(\\d+\\.\\d+|\\d+|\\.\\d+)$/</code>.</p><p>可以修改成:</p><p><code>/^[+-]?(?:\\d+\\.\\d+|\\d+|\\.\\d+)$/</code>.</p><h3 id="独立出确定字符" tabindex="-1"><a class="header-anchor" href="#独立出确定字符"><span>独立出确定字符</span></a></h3><p>例如<code>/a+/</code>, 可以修改成<code>/aa*/</code>.</p><p>因为后者能比前者多确定了字符a. 这样会在第四步中, 加快判断是否匹配失败, 进而加快移位的速度.</p><h3 id="提取分支公共部分" tabindex="-1"><a class="header-anchor" href="#提取分支公共部分"><span>提取分支公共部分</span></a></h3><p>比如/<code>^abc|^def/</code>, 修改成<code>/^(?:abc|def)/</code>.</p><p>又比如<code>/this|that/</code>, 修改成<code>/th(?:is|at)/</code>.</p><p>这样做, 可以减少匹配过程中可消除的重复.</p><h3 id="减少分支数量缩小范围" tabindex="-1"><a class="header-anchor" href="#减少分支数量缩小范围"><span>减少分支数量缩小范围</span></a></h3><p><code>/red|read/</code>, 可以修改成<code>/rea?d/</code>. 此时分支和量词产生的回溯的成本是不一样的. 但这样优化后, 可读性会降低的.</p>',84)])])}const Z=t(D,[["render",E]]),T=JSON.parse('{"path":"/knowledge/tools/regular_expression/build.html","title":"构建","lang":"zh-CN","frontmatter":{"title":"构建","createTime":"2025/12/27 00:05:52","description":"对于一门语言的掌握程度怎么样, 可以有两个角度来衡量: 读和写. 不仅要看懂别人的解决方案, 也要能独立地解决问题. 代码是这样, 正则表达式也是这样. 与读相比, 写往往更为重要, 这个道理是不言而喻的. 对正则的运用, 首重就是:如何针对问题, 构建一个合适的正则表达式? 平衡法则 构建正则有一点非常重要, 需要做到下面几点的平衡: 匹配预期的字符...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"构建\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-04T07:26:46.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/knowledge/tools/regular_expression/build.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"构建"}],["meta",{"property":"og:description","content":"对于一门语言的掌握程度怎么样, 可以有两个角度来衡量: 读和写. 不仅要看懂别人的解决方案, 也要能独立地解决问题. 代码是这样, 正则表达式也是这样. 与读相比, 写往往更为重要, 这个道理是不言而喻的. 对正则的运用, 首重就是:如何针对问题, 构建一个合适的正则表达式? 平衡法则 构建正则有一点非常重要, 需要做到下面几点的平衡: 匹配预期的字符..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-04T07:26:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-04T07:26:46.000Z"}]]},"readingTime":{"minutes":6.09,"words":1828},"git":{"createdTime":1770190006000,"updatedTime":1770190006000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"knowledge/tools/regular_expression/build.md","headers":[]}');export{Z as comp,T as data};
