import{_ as d,c as r,e as l,a as e,b as o,d as n,w as s,r as c,o as i}from"./app-D-vpM8RX.js";const p={};function g(h,t){const a=c("VPLink");return i(),r("div",null,[t[3]||(t[3]=l('<p><strong>模板</strong> 是 <strong>Mock Service</strong> 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析.</p><h2 id="什么是模板字符串" tabindex="-1"><a class="header-anchor" href="#什么是模板字符串"><span>什么是模板字符串?</span></a></h2><p>模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑.</p><h2 id="核心标识符" tabindex="-1"><a class="header-anchor" href="#核心标识符"><span>核心标识符</span></a></h2><p>模板使用了<strong>标识符</strong>机制来区分不同的资源类型:</p><ul><li><strong><code>$</code> (生成器)</strong>: 代表调用一个动态数据生成逻辑. 例如 <code>{{$string.uuid}}</code>.</li><li><strong><code>@</code> (变量)</strong>: 代表引用全局变量系统中的静态或动态存储值. 例如 <code>{{@userName}}</code>.</li></ul><h3 id="语法结构解析" tabindex="-1"><a class="header-anchor" href="#语法结构解析"><span>语法结构解析</span></a></h3><p>一个典型的模板定义如下:</p><p><code>{{标识符主体(参数)|处理器(参数)}}</code></p><ul><li><strong>双大括号 <code>{{ }}</code></strong>: 模板的边界标识符.</li><li><strong>分类与定位</strong>: <ul><li><strong>生成器</strong>: 使用 <code>{{$分类ID.生成器ID(参数)}}</code>.</li><li><strong>变量</strong>: 使用 <code>{{@变量名}}</code>.</li></ul></li><li><strong>处理链 <code>|</code></strong>: 初始值(无论是生成的还是取值的)会沿着管道依次传递给处理器进行二次加工.</li><li><strong>参数传递 <code>()</code></strong>: <ul><li><strong>对象参数</strong>: 使用 <code>{key=value}</code> 形式. 例如 <code>({length=10,type=&quot;hex&quot;})</code>.</li><li><strong>简单参数</strong>: 如果方法只需一个参数, 可直接简写. 例如 <code>(114514)</code>.</li><li><strong>赋值符</strong>: 参数内部统一使用 <code>=</code> 进行赋值, 多个参数间用 <code>,</code> 分隔.</li></ul></li></ul><h2 id="变量系统" tabindex="-1"><a class="header-anchor" href="#变量系统"><span>变量系统</span></a></h2><p>于 [0.0.3] 版本引入.</p><p>变量系统允许你在 Mock 过程中实现数据的跨区域共享与持久化.</p><h3 id="变量的引用与处理" tabindex="-1"><a class="header-anchor" href="#变量的引用与处理"><span>变量的引用与处理</span></a></h3><p>你可以直接通过 <code>@</code> 符号访问存储在 <strong>mockService</strong> 中的变量, 并且变量同样支持使用处理器:</p><p><code>{{@orderId|upper}}</code></p><blockquote><p><strong>注意</strong>: 由于变量不属于特定的生成器分类, 变量所使用的处理器将会在<strong>全局处理器池</strong>中进行全域搜索.</p></blockquote><h2 id="进阶特性" tabindex="-1"><a class="header-anchor" href="#进阶特性"><span>进阶特性</span></a></h2><h3 id="递归嵌套" tabindex="-1"><a class="header-anchor" href="#递归嵌套"><span>递归嵌套</span></a></h3><p>模板支持<strong>深度嵌套</strong>. 你可以在一个模板的参数位置, 嵌入另一个完整的模板. 解析器会从最内层开始递归执行, 实现极具灵活性的组合.</p><blockquote><p><strong>示例概念</strong>: <code>{{$string.uuid|concat(&quot;{{$string.uuid}})&quot;)}}</code></p><p>先生成一个uuid, 随后在生成一个uuid, 最后将这两个字符串拼接起来.</p></blockquote><h2 id="快速查阅表" tabindex="-1"><a class="header-anchor" href="#快速查阅表"><span>快速查阅表</span></a></h2><table><thead><tr><th style="text-align:left;">符号</th><th style="text-align:left;">含义</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>{{...}}</code></td><td style="text-align:left;">模板容器</td><td style="text-align:left;"><code>{{$string.uuid}}</code></td></tr><tr><td style="text-align:left;"><code>$</code></td><td style="text-align:left;">标识符: 调用生成器</td><td style="text-align:left;"><code>{{$date.now}}</code></td></tr><tr><td style="text-align:left;"><code>@</code></td><td style="text-align:left;">标识符: 引用全局变量</td><td style="text-align:left;"><code>{{@userToken}}</code></td></tr><tr><td style="text-align:left;"><code>.</code></td><td style="text-align:left;">路径分隔符</td><td style="text-align:left;"><code>category.generator</code></td></tr><tr><td style="text-align:left;"><code>|</code></td><td style="text-align:left;">处理链 (管道)</td><td style="text-align:left;"><code>{{@name|upper|trim}}</code></td></tr><tr><td style="text-align:left;"><code>(...)</code></td><td style="text-align:left;">参数区域</td><td style="text-align:left;"><code>(limit=10)</code></td></tr><tr><td style="text-align:left;"><code>=</code></td><td style="text-align:left;">参数赋值</td><td style="text-align:left;"><code>key=value</code></td></tr></tbody></table>',23)),e("p",null,[t[1]||(t[1]=o("倒也没必要手动硬背, 我们提供了 ",-1)),n(a,{href:"./generate_template"},{default:s(()=>[...t[0]||(t[0]=[e("code",null,"generateTemplate",-1)])]),_:1}),t[2]||(t[2]=o(" 方法来辅助你生成这些字符串的喵~",-1))])])}const u=d(p,[["render",g]]),f=JSON.parse('{"path":"/project/mock_service/template/template.html","title":"模板字符串","lang":"zh-CN","frontmatter":{"title":"模板字符串","createTime":"2026/02/06 18:17:19","description":"模板 是 Mock Service 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析. 什么是模板字符串? 模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑. 核心标识符 模板使用了标识符机制来区分不同的资源类型: $ (生成器): 代表调用一个动态数据生成逻辑. 例如 {{$string.uui...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"模板字符串\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-11T18:05:00.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/project/mock_service/template/template.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"模板字符串"}],["meta",{"property":"og:description","content":"模板 是 Mock Service 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析. 什么是模板字符串? 模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑. 核心标识符 模板使用了标识符机制来区分不同的资源类型: $ (生成器): 代表调用一个动态数据生成逻辑. 例如 {{$string.uui..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-11T18:05:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-11T18:05:00.000Z"}]]},"readingTime":{"minutes":2.24,"words":671},"git":{"createdTime":1770539937000,"updatedTime":1770833100000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"project/mock_service/template/template.md","headers":[]}');export{u as comp,f as data};
