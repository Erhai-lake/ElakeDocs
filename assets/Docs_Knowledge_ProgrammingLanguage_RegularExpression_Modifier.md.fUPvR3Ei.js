import{_ as t,c as d,o,a6 as a}from"./chunks/framework.Du9XbX32.js";const x=JSON.parse('{"title":"修饰符","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/Modifier.md","filePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/Modifier.md","lastUpdated":1742722027000}'),c={name:"Docs/Knowledge/ProgrammingLanguage/RegularExpression/Modifier.md"};function n(r,e,l,i,s,g){return o(),d("div",null,e[0]||(e[0]=[a('<h1 id="修饰符" tabindex="-1">修饰符 <a class="header-anchor" href="#修饰符" aria-label="Permalink to &quot;修饰符&quot;">​</a></h1><p>用于指定额外的匹配策略</p><p>修饰符不写在正则表达式里, 修饰符位于表达式之外</p><p><code>/正则表达式/修饰符</code></p><p>修饰符可以使用多个.例如<code>/正则表达式/igm</code></p><p>常用的修饰符:</p><table tabindex="0"><thead><tr><th style="text-align:center;">修饰符</th><th style="text-align:center;">含义</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>i</code></td><td style="text-align:center;">不区分大小写</td><td style="text-align:center;">将匹配设置为不区分大小写, 搜索时不区分大小写: <code>A</code>和<code>a</code>没有区别</td></tr><tr><td style="text-align:center;"><code>g</code></td><td style="text-align:center;">全局匹配</td><td style="text-align:center;">查找所有的匹配项</td></tr><tr><td style="text-align:center;"><code>m</code></td><td style="text-align:center;">多行匹配</td><td style="text-align:center;">使边界字符<code>^</code>和<code>$</code>匹配每一行的开头和结尾, 记住是多行, 而不是整个字符串的开头和结尾</td></tr><tr><td style="text-align:center;"><code>s</code></td><td style="text-align:center;">特殊字符圆点<code>.</code>中包含换行符 <code>\\n</code></td><td style="text-align:center;">默认情况下的圆点<code>.</code>是匹配除换行符 <code>\\n</code>之外的任何字符, 加上<code>s</code>修饰符之后, <code>.</code>中包含换行符<code>\\n</code></td></tr></tbody></table>',7)]))}const _=t(c,[["render",n]]);export{x as __pageData,_ as default};
