import{_ as o,c,e as d,o as a}from"./app-PXrWi8_d.js";const t="/assets/5a0fd35ae235cf87606604655be62a9b23331738-BrOFVMn_.png",i="/assets/487d4c104afcc86af53403935cf4e007ad5a6654-BXpUi9oz.png",p="/assets/a3a41d415c158cd259a0b3d806b1c38cd82813af-BPhgKZPC.png",n="/assets/3ddfabb0ddc78d271575e4b39c867af17d28fad3-DKs9P7kY.png",s="/assets/fd1b66fbe974c35033144c10591cc7672d0921e8-bLZ7H6bP.png",r="/assets/5dedbf0b5432386b93f25bf3965940d96aa45516-CHgJUQmR.png",l="/assets/e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c-BHLplDir.png",f={};function b(g,e){return a(),c("div",null,[...e[0]||(e[0]=[d('<div class="hint-container note"><p class="hint-container-title">注</p><p>再次强调, 正则表达式是匹配模式, 要么匹配字符, 要么匹配位置. 请记住这句话.</p><p>然而大部分人学习正则时, 对于匹配位置的重视程度没有那么高.</p></div><h2 id="什么是位置" tabindex="-1"><a class="header-anchor" href="#什么是位置"><span>什么是位置</span></a></h2><p>位置是相邻字符之间的位置. 例如, 下图中箭头所指的地方.</p><figure><img src="'+t+'" alt="5a0fd35ae235cf87606604655be62a9b23331738" tabindex="0" loading="lazy"><figcaption>5a0fd35ae235cf87606604655be62a9b23331738</figcaption></figure><h2 id="如何匹配位置" tabindex="-1"><a class="header-anchor" href="#如何匹配位置"><span>如何匹配位置</span></a></h2><p>共有6个锚字符.</p><p><code>^</code>, <code>$</code>, <code>\\b</code>, <code>\\B</code>, <code>(?=p)</code>, <code>(?!p)</code>.</p><h3 id="前两个" tabindex="-1"><a class="header-anchor" href="#前两个"><span>前两个</span></a></h3><p><code>^</code>(脱字符)匹配开头, 在多行匹配中匹配行开头.</p><p><code>$</code>(美元符号)匹配结尾, 在多行匹配中匹配行结尾.</p><figure><img src="'+i+'" alt="487d4c104afcc86af53403935cf4e007ad5a6654" tabindex="0" loading="lazy"><figcaption>487d4c104afcc86af53403935cf4e007ad5a6654</figcaption></figure><h3 id="中间两个" tabindex="-1"><a class="header-anchor" href="#中间两个"><span>中间两个</span></a></h3><p><code>\\b</code>是单词边界, 具体就是<code>\\w</code>和<code>\\W</code>之间的位置, 也包括<code>\\w</code>和<code>^</code>之间的位置, 也包括<code>\\w</code>和<code>$</code>之间的位置.</p><p>比如一个文件名是<code>[JS] Demo.js</code>中的<code>\\b</code>.</p><figure><img src="'+p+'" alt="a3a41d415c158cd259a0b3d806b1c38cd82813af" tabindex="0" loading="lazy"><figcaption>a3a41d415c158cd259a0b3d806b1c38cd82813af</figcaption></figure><p>为什么是这样呢?仔细看看呢~</p><p>首先, 我们知道, <code>\\w</code>是字符组<code>[0-9a-zA-Z_]</code>的简写形式, 即<code>\\w</code>是字母数字或者下划线的中任何一个字符. 而<code>\\W</code>是排除字符组<code>[^0-9a-zA-Z_]</code>的简写形式, 即<code>\\W</code>是<code>\\w</code>以外的任何一个字符.</p><p>此时我们可以看看<code>[#JS#] #Demo#.#js#</code>中的每一个<code>#</code>是怎么来的.</p><ul><li>第一个<code>#</code>, 两边是<code>[</code>与<code>J</code>, 是<code>\\W</code>和<code>\\w</code>之间的位置.</li><li>第二个<code>#</code>, 两边是<code>S</code>与<code>]</code>, 也就是<code>\\w</code>和<code>\\W</code>之间的位置.</li><li>第三个<code>#</code>, 两边是空格与<code>D</code>, 也就是<code>\\W</code>和<code>\\w</code>之间的位置.</li><li>第四个<code>#</code>, 两边是<code>o</code>与<code>.</code>, 也就是<code>\\w</code>和<code>\\W</code>之间的位置.</li><li>第五个<code>#</code>, 两边是<code>.</code>与<code>j</code>, 也就是<code>\\W</code>和<code>\\w</code>之间的位置.</li><li>第六个<code>#</code>, 其对应的位置是结尾, 但其前面的字符<code>s</code>是<code>\\w</code>, 即<code>\\w</code>和<code>$</code>之间的位置.</li></ul><p>知道了<code>\\b</code>的概念后, 那么<code>\\B</code>也就相对好理解了.</p><p><code>\\B</code>就是<code>\\b</code>的反面的意思.非单词边界/例如在字符串中所有位置中.扣掉<code>\\b</code>.剩下的都是<code>\\B</code>的.</p><p>具体说来就是<code>\\w</code>与<code>\\w</code>, <code>\\W</code>与<code>\\W</code>, <code>^</code>与<code>\\W</code>, <code>\\W</code>与<code>$</code>之间的位置.</p><p>比如上面的例子, 把所有<code>\\B</code>替换成<code>#</code>.</p><figure><img src="'+n+'" alt="3ddfabb0ddc78d271575e4b39c867af17d28fad3" tabindex="0" loading="lazy"><figcaption>3ddfabb0ddc78d271575e4b39c867af17d28fad3</figcaption></figure><h3 id="后两个" tabindex="-1"><a class="header-anchor" href="#后两个"><span>后两个</span></a></h3><p><code>(?=p)</code>, 其中<code>p</code>是一个子模式, 即<code>p</code>前面的位置.</p><p>比如<code>(?=l)</code>, 表示<code>l</code>字符前面的位置, 例如.</p><p><img src="'+s+'" alt="fd1b66fbe974c35033144c10591cc7672d0921e8" loading="lazy">而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思.</p><figure><img src="'+r+'" alt="5dedbf0b5432386b93f25bf3965940d96aa45516" tabindex="0" loading="lazy"><figcaption>5dedbf0b5432386b93f25bf3965940d96aa45516</figcaption></figure><h2 id="位置的特性" tabindex="-1"><a class="header-anchor" href="#位置的特性"><span>位置的特性</span></a></h2><p>对于位置的理解, 我们可以理解成空字符<code> &quot;&quot;</code>.</p><p>比如<code>&quot;hello&quot;</code>字符串等价于如下的形式.</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;</code>.</p><p>也就是.</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</code>.</p><p>因此, 把<code>/^hello$/</code>写成<code>/^^hello?$/</code>, 是没有任何问题的.</p><div class="hint-container note"><p class="hint-container-title">注</p><p>如果你想写屎山代码, 甚至可以写成更复杂.</p><p><code>/(?=he)^^he(?=\\w)llo$\\b\\b$/</code>.</p><figure><img src="'+l+'" alt="e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c" tabindex="0" loading="lazy"><figcaption>e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c</figcaption></figure></div><p>也就是说字符之间的位置, 可以写成多个.</p><p>把位置理解空字符, 是对位置非常有效的理解方式.</p>',39)])])}const u=o(f,[["render",b]]),m=JSON.parse('{"path":"/knowledge/tools/regular_expression/position_matching.html","title":"位置匹配","lang":"zh-CN","frontmatter":{"title":"位置匹配","createTime":"2025/12/26 23:19:41","description":"注 再次强调, 正则表达式是匹配模式, 要么匹配字符, 要么匹配位置. 请记住这句话. 然而大部分人学习正则时, 对于匹配位置的重视程度没有那么高. 什么是位置 位置是相邻字符之间的位置. 例如, 下图中箭头所指的地方. 5a0fd35ae235cf87606604655be62a9b233317385a0fd35ae235cf87606604655b...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"位置匹配\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-04T07:26:46.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/knowledge/tools/regular_expression/position_matching.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"位置匹配"}],["meta",{"property":"og:description","content":"注 再次强调, 正则表达式是匹配模式, 要么匹配字符, 要么匹配位置. 请记住这句话. 然而大部分人学习正则时, 对于匹配位置的重视程度没有那么高. 什么是位置 位置是相邻字符之间的位置. 例如, 下图中箭头所指的地方. 5a0fd35ae235cf87606604655be62a9b233317385a0fd35ae235cf87606604655b..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-04T07:26:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-04T07:26:46.000Z"}]]},"readingTime":{"minutes":2.55,"words":764},"git":{"createdTime":1770190006000,"updatedTime":1770190006000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"knowledge/tools/regular_expression/position_matching.md","headers":[]}');export{u as comp,m as data};
