import{_ as e,c as a,e as c,o as d}from"./app-PXrWi8_d.js";const s="/assets/08c0485f3168442650ae37a106d3346b4be02cff-BbD4UqgK.png",n="/assets/82f1865377798741ee8e8805c59cb9576e65954e-CrNanSa_.png",l="/assets/d1a417e210f391b557b95a4fb2b4f983d50c8054-CHVXBNbO.png",r="/assets/4c14b82cf12272f8e27743a3934fcd9c5f107650-DZxg6Gwn.png",i="/assets/4dcfc861afd2eff76d26f97351e35c76c927ad1e-D6CWy9kf.png",f="/assets/330825db09d623f59112ab26a3e31543fd73074a-BGRaiRIS.png",o="/assets/6b625809f8ef3deb1187aa9f6de4b4c4a7220ede-CrLtjElA.png",b="/assets/bbdb33d93a057da294cd5b8752d326ce0f08e48e-BUdLYp-l.png",g="/assets/51e8a34a76c3c0c9037dc571b7b3019446554a73-BAOlFWYi.png",p="/assets/89faabae19a9de794eeba0cecb2c67b9b2f9bf4b-QuQKFa9M.png",y="/assets/38c44e3f207cea6846fbe960b261b665e8686d2d-0O_A5Xzo.png",m="/assets/f73806243d02f6ea367519e508b6365d1262cad8-P-HdDgqM.png",_="/assets/851260e55531d61eafbea6d92320a0159694c7a6-Co0H8ZvD.png",x="/assets/0f0cb5dff80f7d924579983654e7896301494606-NvMYcdzx.png",h="/assets/1243f3508635d358fe1b7c2f174cab42b3475571-5pm7k3cD.png",z="/assets/a867957350ea82bb895a01fb00d92506e1e15a0e-CGq8Kghb.png",u="/assets/5ebe76407fa5a92bae50a593eb6859fed4c37e45-TQhZWmqj.png",k="/assets/521752ac8b120a6ac100acf854271e1d532fe07e-D-lUKMeL.png",D="/assets/4bed40bfe8cb43edfaea4dc9661123c28dab7f62-CmWa9ebg.png",B="/assets/ea3d9c3dcb32a399c1b98df10e4e0b8e4e983226-DHh5mjh3.png",C="/assets/4c985724247c053fc3de8ff22f198625f22125fe-DQo4nlIN.png",N="/assets/4c0241c4cbee1027cf79a3523c5b61b649fbc049-r7tyjcxe.png",Y="/assets/ccf159593101b2a8393d77ebe9852cf5c37bd1cb-DFFjCt8k.png",j="/assets/9742719e7f1a0ebba4a2924975cf388f4f7f8f53-DItWr46X.png",v="/assets/a51461eedc41f293f40d095381b87ca4196d8573-D6sQGLRe.png",A="/assets/3a65bfb335c0b168668b0f4e13aa5d3715378ca1-CoRXpJhn.png",L="/assets/b8a60b99a12397d01a2469980251c940019e442b-C4xpFrdz.png",O="/assets/9d27da851472275ac99a924463b0278625c86549-DbAXJg8N.png",T="/assets/721726745c037f933428a1828d65204013501f89-KLpW1z1k.png",Z="/assets/02df41964e59f8f0301e2a71f489b04ebe1917b7-CwauHJmX.png",K="/assets/76f02a9aa5fce837adb33e32a0db1aea2ec6eb5f-MtDLbJuy.png",w="/assets/bbcf235cf51e7b6c31dac1f4507fe268f11ee144-D1qpybyt.png",E="/assets/47fce99ab3122a3320a66116c28dc5a4829c2ca1-Ca_h1LHt.png",Q="/assets/83531b70cae629e3ce568b071bee11516a219eae-DNiZZZiK.png",W="/assets/e87954f62c9366aa1380188947ac619e5a78a61f-BrEfv-cu.png",q="/assets/c6c826ce7cb7261e1fce5efda1a006c9cf038ced-BY_ju35f.png",F="/assets/51765e2520dfe5a5a975f5f05f34805f9b785ecd-BdHj4kzd.png",M="/assets/50ab1e3bb60ba1b49b177902aee024ce09b89f19-vYeSQsKN.png",S="/assets/3b7d3cfe9fe579d54ae5a2545e71a52d98c5a0ff-UFfnUMzS.png",H="/assets/3c0eaf162b11a8b0d70cb7926879e16e3f101998-Agsk5zwC.png",R="/assets/0be8d6035d60fdf8770c38728b14e4fa806b9b92-Dv4BYShN.png",U="/assets/124701f7c154d22f535406c1baf721a000c048a2-cKcYQYAL.png",X="/assets/22e0227e4fe9351cf8d9191f47b1a1651d22a07e-D6us_JuF.png",G="/assets/87075e86b72f8c27c8e871c91baf0b60150f84d6-Bsl4eV8l.png",I="/assets/c67b062022ca60747592d8092beb9fefeecf58eb-E4mThk8D.png",J="/assets/c669ef87794974405dfbfd64bf198b509344d2a4-DQIKfL_z.png",P="/assets/ae33abb45cb82fb4e7945810c53991721a55df06-BO-tmmiI.png",V="/assets/42d1f10dfab7d7ba0f2461ea22c0bfaf88fe2f4f-DW53j-kN.png",$="/assets/eae2b65be51a08923fa53fa82c0fa09d8f55d1c8-DO4-REI-.png",tt="/assets/779cb3d88724f252cd9998e115c81e558f63c40e-BMAuYfiw.png",et="/assets/69806d335f88e35bcffeb3cd390251391d3e63f8-qLOf9rY1.png",at="/assets/2b1f4e52075c074be414eeda23e0b6f2673ba7c2-nQO6GGAN.png",ct="/assets/b1ef3675b6cfa573046f349119d97146a13614c0-Dojx2fNa.png",dt="/assets/e9d829eb19637df562581231a5d9b7204a462a31-BiUuXTKi.png",st="/assets/d76d6442d0598a24752470fa7e568f02ff5de7d4-Rq_WyTyj.png",nt="/assets/1b692bb5fe3a50751c9c1e5fd2141245c27ac9d6-CZkOZpCr.png",lt="/assets/39bfc3e333aaf81fe57eda79bc8576b478bffad4-DLw9yz2s.png",rt="/assets/aea6885e45e76c7c90511a47cbfda098298758c2-Bu5yshY2.png",it="/assets/822e74c734b83eadd66631fb371547263ea0658e-CSvWitqA.png",ft="/assets/8de6f9a40aad780a5ea0d60605b606d55d0ddd44-Bie-OaFs.png",ot="/assets/33778d55b8203e60d1821ea62a47adf87c5c628f-BPOiUAY4.png",bt={};function gt(pt,t){return d(),a("div",null,[...t[0]||(t[0]=[c('<p>学习正则表达式, 是需要懂点儿匹配原理的.</p><p>而研究匹配原理时, 有两个字出现的频率比较高: <strong>回溯</strong>.</p><p>假设我们的正则是<code>/ab{1, 3}c/</code>, 其可视化形式是.</p><figure><img src="'+s+'" alt="08c0485f3168442650ae37a106d3346b4be02cff" tabindex="0" loading="lazy"><figcaption>08c0485f3168442650ae37a106d3346b4be02cff</figcaption></figure><h2 id="没有回溯的匹配" tabindex="-1"><a class="header-anchor" href="#没有回溯的匹配"><span>没有回溯的匹配</span></a></h2><p>而当目标字符串是<code>abbbc</code>时, 就没有所谓的<strong>回溯</strong>.其匹配过程如下:</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">正则</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+n+'" alt="82f1865377798741ee8e8805c59cb9576e65954e" loading="lazy"></td><td style="text-align:center;"><img src="'+l+'" alt="d1a417e210f391b557b95a4fb2b4f983d50c8054" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+r+'" alt="4c14b82cf12272f8e27743a3934fcd9c5f107650" loading="lazy"></td><td style="text-align:center;"><img src="'+i+'" alt="4dcfc861afd2eff76d26f97351e35c76c927ad1e" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+f+'" alt="330825db09d623f59112ab26a3e31543fd73074a" loading="lazy"></td><td style="text-align:center;"><img src="'+o+'" alt="6b625809f8ef3deb1187aa9f6de4b4c4a7220ede" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+b+'" alt="bbdb33d93a057da294cd5b8752d326ce0f08e48e" loading="lazy"></td><td style="text-align:center;"><img src="'+g+'" alt="51e8a34a76c3c0c9037dc571b7b3019446554a73" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+p+'" alt="89faabae19a9de794eeba0cecb2c67b9b2f9bf4b" loading="lazy"></td><td style="text-align:center;"><img src="'+y+'" alt="38c44e3f207cea6846fbe960b261b665e8686d2d" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+m+'" alt="f73806243d02f6ea367519e508b6365d1262cad8" loading="lazy"></td><td style="text-align:center;"><img src="'+_+'" alt="851260e55531d61eafbea6d92320a0159694c7a6" loading="lazy"></td></tr></tbody></table><p>其中子表达式<code>b{1, 3}</code>表示<code>b</code>字符连续出现1到3次.</p><h2 id="有回溯的匹配" tabindex="-1"><a class="header-anchor" href="#有回溯的匹配"><span>有回溯的匹配</span></a></h2><p>如果目标字符串是<code>abbc</code>中间就有<strong>回溯</strong>.</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">正则</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+x+'" alt="0f0cb5dff80f7d924579983654e7896301494606" loading="lazy"></td><td style="text-align:center;"><img src="'+h+'" alt="1243f3508635d358fe1b7c2f174cab42b3475571" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+z+'" alt="a867957350ea82bb895a01fb00d92506e1e15a0e" loading="lazy"></td><td style="text-align:center;"><img src="'+u+'" alt="5ebe76407fa5a92bae50a593eb6859fed4c37e45" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+k+'" alt="521752ac8b120a6ac100acf854271e1d532fe07e" loading="lazy"></td><td style="text-align:center;"><img src="'+D+'" alt="4bed40bfe8cb43edfaea4dc9661123c28dab7f62" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+B+'" alt="ea3d9c3dcb32a399c1b98df10e4e0b8e4e983226" loading="lazy"></td><td style="text-align:center;"><img src="'+C+'" alt="4c985724247c053fc3de8ff22f198625f22125fe" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+N+'" alt="4c0241c4cbee1027cf79a3523c5b61b649fbc049" loading="lazy"></td><td style="text-align:center;"><img src="'+Y+'" alt="ccf159593101b2a8393d77ebe9852cf5c37bd1cb" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+j+'" alt="9742719e7f1a0ebba4a2924975cf388f4f7f8f53" loading="lazy"></td><td style="text-align:center;"><img src="'+v+'" alt="a51461eedc41f293f40d095381b87ca4196d8573" loading="lazy"></td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;"><img src="'+A+'" alt="3a65bfb335c0b168668b0f4e13aa5d3715378ca1" loading="lazy"></td><td style="text-align:center;"><img src="'+L+'" alt="b8a60b99a12397d01a2469980251c940019e442b" loading="lazy"></td></tr></tbody></table><p>图中第5步有红颜色, 表示匹配不成功.</p><p>此时<code>b{1,3}</code>已经匹配到了2个字符<code>b</code>, 准备尝试第三个时, 结果发现接下来的字符是<code>c</code>.</p><p>那么就认为<code>b{1,3}</code>就已经匹配完毕.</p><p>然后状态又回到之前的状态(即第6步, 与第4步一样), 最后再用子表达式<code>c</code>, 去匹配字符<code>c</code>.当然, 此时整个表达式匹配成功了.</p><p>图中的第6步, 就是<strong>回溯</strong>.</p><h2 id="常见的回溯形式" tabindex="-1"><a class="header-anchor" href="#常见的回溯形式"><span>常见的回溯形式</span></a></h2><p>正则表达式匹配字符串的这种方式, 有个学名, 叫回溯法.</p><p>回溯法也称试探法, 它的基本思想是: 从问题的某一种状态(初始状态)出发, 搜索从这种状态出发所能达到的所有<strong>状态</strong>, 当一条路走到尽头的时候(不能再前进), 再后退一步或若干步, 从另一种可能<strong>状态</strong>出发, 继续搜索, 直到所有的<strong>路径</strong>(状态)都试探过.</p><p>这种不断<strong>前进</strong>, 不断<strong>回溯</strong>寻找解的方法, 就称作<strong>回溯法</strong>.</p><p>本质上就是深度优先搜索算法. 其中退到之前的某一步这一过程, 我们称为<mark>回溯</mark>. 从上面的描述过程中, 可以看出, 路走不通时, 就会发生回溯. 即, 尝试匹配失败时, 接下来的一步通常就是回溯.</p><p>道理懂了, 那什么地方会产生呢?</p><h3 id="贪婪量词" tabindex="-1"><a class="header-anchor" href="#贪婪量词"><span>贪婪量词</span></a></h3><p>之前的例子都是贪婪量词相关的.比如<code>b{1,3}</code>, 因为其是贪婪的, 尝试可能的顺序是从多往少的方向去尝试.</p><p>首先会尝试<code>bbb</code>, 然后再看整个正则是否能匹配.不能匹配时, 吐出一个<code>b</code>, 即在<code>bb</code>的基础上, 再继续尝试. 如果还不行, 再吐出一个, 再试. 如果还不行呢? 只能说明匹配失败了.</p><p>虽然局部匹配是贪婪的, 但也要满足整体能正确匹配. 否则, 皮之不存, 毛将焉附?</p><p>此时我们不禁会问, 如果当多个贪婪量词挨着存在, 并相互有冲突时, 此时会是怎样?</p><p>答案是, 先下手为强! 因为深度优先搜索.</p><figure><img src="'+O+'" alt="9d27da851472275ac99a924463b0278625c86549" tabindex="0" loading="lazy"><figcaption>9d27da851472275ac99a924463b0278625c86549</figcaption></figure><p>其中, 前面的<code>\\d{1,3}</code>匹配的是<code>123</code>后面的<code>\\d{1,3}</code>匹配的是<code>45</code>.</p><h3 id="惰性量词" tabindex="-1"><a class="header-anchor" href="#惰性量词"><span>惰性量词</span></a></h3><p>惰性量词就是在贪婪量词后面加个问号. 表示尽可能少的匹配, 比如:</p><figure><img src="'+T+'" alt="721726745c037f933428a1828d65204013501f89" tabindex="0" loading="lazy"><figcaption>721726745c037f933428a1828d65204013501f89</figcaption></figure><p>其中<code>\\d{1,3}?</code>只匹配到一个字符<code>1</code>, 而后面的<code>\\d{1,3}</code>匹配了<code>234</code>.</p><p>虽然惰性量词不贪, 但也会有回溯的现象. 比如正则是:</p><figure><img src="'+Z+'" alt="02df41964e59f8f0301e2a71f489b04ebe1917b7" tabindex="0" loading="lazy"><figcaption>02df41964e59f8f0301e2a71f489b04ebe1917b7</figcaption></figure><p>目标字符串是<code>12345</code>, 匹配过程是:</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">正则</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+K+'" alt="76f02a9aa5fce837adb33e32a0db1aea2ec6eb5f" loading="lazy"></td><td style="text-align:center;"><img src="'+w+'" alt="bbcf235cf51e7b6c31dac1f4507fe268f11ee144" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+E+'" alt="47fce99ab3122a3320a66116c28dc5a4829c2ca1" loading="lazy"></td><td style="text-align:center;"><img src="'+Q+'" alt="83531b70cae629e3ce568b071bee11516a219eae" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+W+'" alt="e87954f62c9366aa1380188947ac619e5a78a61f" loading="lazy"></td><td style="text-align:center;"><img src="'+q+'" alt="c6c826ce7cb7261e1fce5efda1a006c9cf038ced" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+F+'" alt="51765e2520dfe5a5a975f5f05f34805f9b785ecd" loading="lazy"></td><td style="text-align:center;"><img src="'+M+'" alt="50ab1e3bb60ba1b49b177902aee024ce09b89f19" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+S+'" alt="3b7d3cfe9fe579d54ae5a2545e71a52d98c5a0ff" loading="lazy"></td><td style="text-align:center;"><img src="'+H+'" alt="3c0eaf162b11a8b0d70cb7926879e16e3f101998" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+R+'" alt="0be8d6035d60fdf8770c38728b14e4fa806b9b92" loading="lazy"></td><td style="text-align:center;"><img src="'+U+'" alt="124701f7c154d22f535406c1baf721a000c048a2" loading="lazy"></td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;"><img src="'+X+'" alt="22e0227e4fe9351cf8d9191f47b1a1651d22a07e" loading="lazy"></td><td style="text-align:center;"><img src="'+G+'" alt="87075e86b72f8c27c8e871c91baf0b60150f84d6" loading="lazy"></td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;"><img src="'+I+'" alt="c67b062022ca60747592d8092beb9fefeecf58eb" loading="lazy"></td><td style="text-align:center;"><img src="'+J+'" alt="c669ef87794974405dfbfd64bf198b509344d2a4" loading="lazy"></td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;"><img src="'+P+'" alt="ae33abb45cb82fb4e7945810c53991721a55df06" loading="lazy"></td><td style="text-align:center;"><img src="'+V+'" alt="42d1f10dfab7d7ba0f2461ea22c0bfaf88fe2f4f" loading="lazy"></td></tr></tbody></table><p>知道你不贪, 很知足, 但是为了整体匹配成, 没办法, 也只能给你多塞点了.因此最后<code>\\d{1,3}?</code>匹配的字符是<code>12</code>, 是两个数字, 而不是一个.</p><h3 id="分支结构" tabindex="-1"><a class="header-anchor" href="#分支结构"><span>分支结构</span></a></h3><p>我们知道分支也是惰性的, 比如<code>/can|candy/</code>, 去匹配字符串<code>candy</code>, 得到的结果是<code>can</code>, 因为分支会一个一个尝试, 如果前面的满足了, 后面就不会再试验了.</p><p>分支结构, 可能前面的子模式会形成了局部匹配, 如果接下来表达式整体不匹配时, 仍会继续尝试剩下的分支. 这种尝试也可以看成一种回溯.</p><p>比如正则.</p><figure><img src="'+$+'" alt="eae2b65be51a08923fa53fa82c0fa09d8f55d1c8" tabindex="0" loading="lazy"><figcaption>eae2b65be51a08923fa53fa82c0fa09d8f55d1c8</figcaption></figure><p>目标字符串是<code>candy</code>, 匹配过程.</p><table><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">正则</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+tt+'" alt="779cb3d88724f252cd9998e115c81e558f63c40e" loading="lazy"></td><td style="text-align:center;"><img src="'+et+'" alt="69806d335f88e35bcffeb3cd390251391d3e63f8" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+at+'" alt="2b1f4e52075c074be414eeda23e0b6f2673ba7c2" loading="lazy"></td><td style="text-align:center;"><img src="'+ct+'" alt="b1ef3675b6cfa573046f349119d97146a13614c0" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+dt+'" alt="e9d829eb19637df562581231a5d9b7204a462a31" loading="lazy"></td><td style="text-align:center;"><img src="'+st+'" alt="d76d6442d0598a24752470fa7e568f02ff5de7d4" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+nt+'" alt="1b692bb5fe3a50751c9c1e5fd2141245c27ac9d6" loading="lazy"></td><td style="text-align:center;"><img src="'+lt+'" alt="39bfc3e333aaf81fe57eda79bc8576b478bffad4" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+rt+'" alt="aea6885e45e76c7c90511a47cbfda098298758c2" loading="lazy"></td><td style="text-align:center;"><img src="'+it+'" alt="822e74c734b83eadd66631fb371547263ea0658e" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+ft+'" alt="8de6f9a40aad780a5ea0d60605b606d55d0ddd44" loading="lazy"></td><td style="text-align:center;"><img src="'+ot+'" alt="33778d55b8203e60d1821ea62a47adf87c5c628f" loading="lazy"></td></tr></tbody></table><p>上面第5步, 虽然没有回到之前的状态, 但仍然回到了分支结构, 尝试下一种可能.所以, 可以认为它是一种回溯的.</p>',47)])])}const mt=e(bt,[["render",gt]]),_t=JSON.parse('{"path":"/knowledge/tools/regular_expression/principle_of_backtracking.html","title":"回溯法原理","lang":"zh-CN","frontmatter":{"title":"回溯法原理","createTime":"2025/12/26 23:19:41","description":"学习正则表达式, 是需要懂点儿匹配原理的. 而研究匹配原理时, 有两个字出现的频率比较高: 回溯. 假设我们的正则是/ab{1, 3}c/, 其可视化形式是. 08c0485f3168442650ae37a106d3346b4be02cff08c0485f3168442650ae37a106d3346b4be02cff 没有回溯的匹配 而当目标字符串是...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"回溯法原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-04T07:26:46.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/knowledge/tools/regular_expression/principle_of_backtracking.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"回溯法原理"}],["meta",{"property":"og:description","content":"学习正则表达式, 是需要懂点儿匹配原理的. 而研究匹配原理时, 有两个字出现的频率比较高: 回溯. 假设我们的正则是/ab{1, 3}c/, 其可视化形式是. 08c0485f3168442650ae37a106d3346b4be02cff08c0485f3168442650ae37a106d3346b4be02cff 没有回溯的匹配 而当目标字符串是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-04T07:26:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-04T07:26:46.000Z"}]]},"readingTime":{"minutes":4.25,"words":1275},"git":{"createdTime":1770190006000,"updatedTime":1770190006000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"knowledge/tools/regular_expression/principle_of_backtracking.md","headers":[]}');export{mt as comp,_t as data};
