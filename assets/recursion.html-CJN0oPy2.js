import{_ as i,c as a,e,o as n}from"./app-CfgUnQTr.js";const t={};function l(p,s){return n(),a("div",null,[...s[0]||(s[0]=[e(`<blockquote><p>突然发现我没写递归, 但是深拷贝要用, 赶紧来补一下.</p></blockquote><p>如果一个函数在内部可以调用其本身, 那么这个函数就是递归函数.</p><p>简单来说就是, 函数内部自己调用自己, 这个函数就是递归函数.</p><p>递归函数的作用和循环效果类似.</p><p>由于递归很容易发生栈溢出(stack overflow), 所以必须要加退出条件<code>return</code>.</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &gt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	num</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">num</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6)])])}const h=i(t,[["render",l]]),k=JSON.parse('{"path":"/knowledge/programming_language/javascript/recursion.html","title":"递归","lang":"zh-CN","frontmatter":{"title":"递归","createTime":"2024/10/02 14:53:08","description":"突然发现我没写递归, 但是深拷贝要用, 赶紧来补一下. 如果一个函数在内部可以调用其本身, 那么这个函数就是递归函数. 简单来说就是, 函数内部自己调用自己, 这个函数就是递归函数. 递归函数的作用和循环效果类似. 由于递归很容易发生栈溢出(stack overflow), 所以必须要加退出条件return.","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-04T07:26:46.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/knowledge/programming_language/javascript/recursion.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"递归"}],["meta",{"property":"og:description","content":"突然发现我没写递归, 但是深拷贝要用, 赶紧来补一下. 如果一个函数在内部可以调用其本身, 那么这个函数就是递归函数. 简单来说就是, 函数内部自己调用自己, 这个函数就是递归函数. 递归函数的作用和循环效果类似. 由于递归很容易发生栈溢出(stack overflow), 所以必须要加退出条件return."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-04T07:26:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-04T07:26:46.000Z"}]]},"readingTime":{"minutes":0.47,"words":142},"git":{"createdTime":1770190006000,"updatedTime":1770190006000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"knowledge/programming_language/javascript/recursion.md","headers":[]}');export{h as comp,k as data};
