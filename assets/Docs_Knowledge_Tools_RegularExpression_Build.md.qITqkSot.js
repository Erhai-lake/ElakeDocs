import{_ as t,c as a,o as d,a6 as c}from"./chunks/framework.ClVMjeck.js";const l="/assets/279caf5c12319439086d23dbe5948d47adef252e.DnmiSzuM.png",o="/assets/a5067377e2b907a5bbb80b33957fb8c135b73e24.lENsdR8P.png",r="/assets/41f451b58f75b4280337816e000ee1dec0eb2051.jTSnE6BV.png",n="/assets/ef6d26401fb989ea8ab06fa7ab96ac6b7b4d721c.C6m5DEmy.png",s="/assets/23b1e7ae90158f65204003938e37939682f1305a.YJzF4Vf3.png",i="/assets/9bd0ea4b8f8da469c2131379d6437fac38ff6722.CDbrRukI.png",p="/assets/c7f432db3324b46338af946af2a7d98f573b8aea.D65GXAoq.png",b="/assets/5b0b02b0326343840f22e3f91d4a99519995d352.BxGNdJJ6.png",f="/assets/76a70ef1d2875cabd5ffe4c451b225dd1752f63a.oUAsi1xm.png",g="/assets/600924080d818f601e3a877e819f5c6ee00b35be.pW4eKboe.png",y="/assets/03084e7233ca1842fcc6dd110e2eb85d5fc7ad51.Dj7RyxDC.png",h="/assets/d9070c5a763f18950db7756780381928c0df65be.DE7oEOEb.png",x="/assets/cce26b8d9180837d9d61e7b0ab46303be3f09df2.DjFOPlrr.png",m="/assets/94e61bc13723bd3fc792ef02b9135bceae94a3a9.D4U-FvAO.png",_="/assets/50edf82c42a5e1459c9f6037b53d9f3977a081d4.Bs0I9jAM.png",u="/assets/3cf9ea3d6d3e624bf023b57b46227d4c36edf920.D8D1-72Q.png",q="/assets/accfc60076b0044f48191966130fa9b13f7f9db7.tUWZ1i5g.png",z="/assets/9d11a76d086eeb8e9351e4ad19d77a33ba5b667a.Cmh_h61X.png",$="/assets/b1afd07a0266dff10447cbb7915f08f9adb39c9b.CQqMfZYX.png",R=JSON.parse('{"title":"构建","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/Tools/RegularExpression/Build.md","filePath":"Docs/Knowledge/Tools/RegularExpression/Build.md","lastUpdated":1754243091000}'),P={name:"Docs/Knowledge/Tools/RegularExpression/Build.md"};function k(D,e,A,E,T,B){return d(),a("div",null,[...e[0]||(e[0]=[c('<h1 id="构建" tabindex="-1">构建 <a class="header-anchor" href="#构建" aria-label="Permalink to &quot;构建&quot;">​</a></h1><p>对于一门语言的掌握程度怎么样, 可以有两个角度来衡量:读和写</p><p>不仅要看懂别人的解决方案, 也要能独立地解决问题.代码是这样, 正则表达式也是这样</p><p>与读相比, 写往往更为重要, 这个道理是不言而喻的</p><p>对正则的运用, 首重就是:如何针对问题, 构建一个合适的正则表达式?</p><h2 id="平衡法则" tabindex="-1">平衡法则 <a class="header-anchor" href="#平衡法则" aria-label="Permalink to &quot;平衡法则&quot;">​</a></h2><p>构建正则有一点非常重要, 需要做到下面几点的平衡:</p><ol><li>匹配预期的字符串</li><li>不匹配非预期的字符串</li><li>可读性和可维护性</li><li>效率</li></ol><h2 id="构建正则前提" tabindex="-1">构建正则前提 <a class="header-anchor" href="#构建正则前提" aria-label="Permalink to &quot;构建正则前提&quot;">​</a></h2><h3 id="是否能使用正则" tabindex="-1">是否能使用正则 <a class="header-anchor" href="#是否能使用正则" aria-label="Permalink to &quot;是否能使用正则&quot;">​</a></h3><p>正则太强大了, 以至于我们随便遇到一个操作字符串问题时, 都会下意识地去想, 用正则该怎么做.但我们始终要提醒自己, 正则虽然强大, 但不是万能的, 很多看似很简单的事情, 还是做不到的</p><p>比如匹配这样的字符串:1010010001....</p><p>虽然很有规律.但是只靠正则就是无能为力</p><h3 id="是否有必要使用正则" tabindex="-1">是否有必要使用正则 <a class="header-anchor" href="#是否有必要使用正则" aria-label="Permalink to &quot;是否有必要使用正则&quot;">​</a></h3><p>要认识到正则的局限, 不要去研究根本无法完成的任务.同时, 也不能走入另一个极端:无所不用正则.能用字符串API解决的简单问题, 就不该正则出马</p><h3 id="是否有必要构建一个复杂的正则" tabindex="-1">是否有必要构建一个复杂的正则 <a class="header-anchor" href="#是否有必要构建一个复杂的正则" aria-label="Permalink to &quot;是否有必要构建一个复杂的正则&quot;">​</a></h3><p>比如密码匹配问题, 要求密码长度6-12位, 由数字, 小写字符和大写字母组成, 但必须至少包括2种字符</p><p><code>/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/</code></p><p>这个正则其实可以使用多个小正则来做:</p><p><code>/^[0-9A-Za-z]{6,12}$/</code></p><p><code>/^[0-9]{6,12}$/</code></p><p><code>/^[A-Z]{6,12}$/</code></p><p><code>/^[a-z]{6,12}$/</code></p><h2 id="准确性" tabindex="-1">准确性 <a class="header-anchor" href="#准确性" aria-label="Permalink to &quot;准确性&quot;">​</a></h2><p>所谓准确性, 就是能匹配预期的目标, 并且不匹配非预期的目标</p><p>这里提到了<strong>预期</strong>二字, 那么我们就需要知道目标的组成规则</p><p>不然没法界定什么样的目标字符串是符合预期的, 什么样的又不是符合预期的</p><p>下面将举例说明, 当目标字符串构成比较复杂时, 该如何构建正则, 并考虑到哪些平衡</p><h3 id="匹配固定电话" tabindex="-1">匹配固定电话 <a class="header-anchor" href="#匹配固定电话" aria-label="Permalink to &quot;匹配固定电话&quot;">​</a></h3><p>比如要匹配如下格式的固定电话号码:</p><p><code>055188888888</code></p><p><code>0551-88888888</code></p><p><code>(0551)88888888</code></p><p>第一步, 了解各部分的模式规则</p><p>上面的电话, 总体上分为区号和号码两部分(不考虑分机号和+86的情形)</p><p>区号是0开头的3到4位数字, 对应的正则是:<code>0\\d{2,3}</code></p><p>号码是非0开头的7到8位数字, 对应的正则是:<code>[1-9]\\d{6,7}</code></p><p>因此, 匹配<code>055188888888</code>的正则是:<code>/^0\\d{2,3}[1-9]\\d{6,7}$/</code></p><p>匹配<code>0551-88888888</code>的正则是:<code>/^0\\d{2,3}-[1-9]\\d{6,7}$/</code></p><p>匹配<code>(0551)88888888</code>的正则是:<code>/^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/</code></p><p>第二步, 明确形式关系</p><p>这三者情形是或的关系, 可以构建分支:</p><p><code>/^0\\d{2,3}[1-9]\\d{6,7}$|^0\\d{2,3}-[1-9]\\d{6,7}$|^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/</code></p><p>提取公共部分:</p><p><code>/^(0\\d{2,3}|0\\d{2,3}-|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/</code></p><p>进一步简写:</p><p><code>/^(0\\d{2,3}-?|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/</code></p><p>其可视化形式:</p><p><img src="'+l+'" alt="279caf5c12319439086d23dbe5948d47adef252e" data-fancybox="gallery" loading="lazy"></p><p>上面的正则构建过程略显罗嗦, 但是这样做, 能保证正则是准确的</p><p>上述三种情形是或的关系，这一点很重要，不然很容易按字符是否出现的情形把正则写成:</p><p><code>/^\\(?0\\d{2,3}\\)?-?[1-9]\\d{6,7}$/</code></p><p>虽然也能匹配上述目标字符串, 但也会匹配<code>(0551-88888888</code>这样的字符串.当然, 这不是我们想要的</p><p>其实这个正则也不是完美的, 因为现实中, 并不是每个3位数和4位数都是一个真实的区号</p><p>这就是一个平衡取舍问题, 一般够用就行</p><h2 id="效率" tabindex="-1">效率 <a class="header-anchor" href="#效率" aria-label="Permalink to &quot;效率&quot;">​</a></h2><p>保证了准确性后, 才需要是否要考虑要优化.大多数情形是不需要优化的, 除非运行的非常慢.什么情形正则表达式运行才慢呢?我们需要考察正则表达式的运行过程(原理)</p><p>正则表达式的运行分为如下的阶段:</p><ol><li>编译</li><li>设定起始位置</li><li>尝试匹配</li><li>匹配失败的话, 从下一位开始继续第3步</li><li>最终结果:匹配成功或失败</li></ol><p>匹配会出现效率问题, 主要出现在上面的第3阶段和第4阶段</p><p>因此, 主要优化手法也是针对这两阶段的</p><h3 id="使用具体型字符组代替通配符消除回溯" tabindex="-1">使用具体型字符组代替通配符消除回溯 <a class="header-anchor" href="#使用具体型字符组代替通配符消除回溯" aria-label="Permalink to &quot;使用具体型字符组代替通配符消除回溯&quot;">​</a></h3><p>而在第三阶段, 最大的问题就是回溯</p><p>例如, 匹配双引用号之间的字符.如, 匹配字符串123<code>abc</code>456中的<code>abc</code></p><p>如果正则用的是:<code>/&quot;.*&quot;/,</code>, 会在第3阶段产生4次回溯(粉色表示<code>.*</code>匹配的内容):</p><table tabindex="0"><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+o+'" alt="a5067377e2b907a5bbb80b33957fb8c135b73e24" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+r+'" alt="41f451b58f75b4280337816e000ee1dec0eb2051" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+n+'" alt="ef6d26401fb989ea8ab06fa7ab96ac6b7b4d721c" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+s+'" alt="23b1e7ae90158f65204003938e37939682f1305a" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+i+'" alt="9bd0ea4b8f8da469c2131379d6437fac38ff6722" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;"><img src="'+p+'" alt="c7f432db3324b46338af946af2a7d98f573b8aea" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;"><img src="'+b+'" alt="5b0b02b0326343840f22e3f91d4a99519995d352" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;"><img src="'+f+'" alt="76a70ef1d2875cabd5ffe4c451b225dd1752f63a" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;"><img src="'+g+'" alt="600924080d818f601e3a877e819f5c6ee00b35be" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">10</td><td style="text-align:center;"><img src="'+y+'" alt="03084e7233ca1842fcc6dd110e2eb85d5fc7ad51" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">11</td><td style="text-align:center;"><img src="'+h+'" alt="d9070c5a763f18950db7756780381928c0df65be" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">12</td><td style="text-align:center;"><img src="'+x+'" alt="cce26b8d9180837d9d61e7b0ab46303be3f09df2" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">13</td><td style="text-align:center;"><img src="'+m+'" alt="94e61bc13723bd3fc792ef02b9135bceae94a3a9" data-fancybox="gallery" loading="lazy"></td></tr></tbody></table><p>如果正则用的是:<code>/&quot;.*?&quot;/</code>, 会产生2次回溯(粉色表示<code>.*?</code>匹配的内容):</p><table tabindex="0"><thead><tr><th style="text-align:center;">步骤</th><th style="text-align:center;">文本</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><img src="'+_+'" alt="50edf82c42a5e1459c9f6037b53d9f3977a081d4" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><img src="'+u+'" alt="3cf9ea3d6d3e624bf023b57b46227d4c36edf920" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><img src="'+q+'" alt="accfc60076b0044f48191966130fa9b13f7f9db7" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><img src="'+z+'" alt="9d11a76d086eeb8e9351e4ad19d77a33ba5b667a" data-fancybox="gallery" loading="lazy"></td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;"><img src="'+$+'" alt="b1afd07a0266dff10447cbb7915f08f9adb39c9b" data-fancybox="gallery" loading="lazy"></td></tr></tbody></table><p>因为回溯的存在, 需要引擎保存多种可能中未尝试过的状态, 以便后续回溯时使用.注定要占用一定的内存</p><p>此时要使用具体化的字符组.来代替通配符<code>.</code>.以便消除不必要的字符.此时使用正则<code>/&quot;[^&quot;]*&quot;/</code>.即可</p><h3 id="使用非捕获型分组" tabindex="-1">使用非捕获型分组 <a class="header-anchor" href="#使用非捕获型分组" aria-label="Permalink to &quot;使用非捕获型分组&quot;">​</a></h3><p>因为括号的作用之一是, 可以捕获分组和分支里的数据.那么就需要内存来保存它们</p><p>当我们不需要使用分组引用和反向引用时, 此时可以使用非捕获分组.例如:</p><p><code>/^[+-]?(\\d+\\.\\d+|\\d+|\\.\\d+)$/</code></p><p>可以修改成:</p><p><code>/^[+-]?(?:\\d+\\.\\d+|\\d+|\\.\\d+)$/</code></p><h3 id="独立出确定字符" tabindex="-1">独立出确定字符 <a class="header-anchor" href="#独立出确定字符" aria-label="Permalink to &quot;独立出确定字符&quot;">​</a></h3><p>例如<code>/a+/</code>, 可以修改成<code>/aa*/</code></p><p>因为后者能比前者多确定了字符a.这样会在第四步中, 加快判断是否匹配失败, 进而加快移位的速度</p><h3 id="提取分支公共部分" tabindex="-1">提取分支公共部分 <a class="header-anchor" href="#提取分支公共部分" aria-label="Permalink to &quot;提取分支公共部分&quot;">​</a></h3><p>比如/<code>^abc|^def/</code>, 修改成<code>/^(?:abc|def)/</code></p><p>又比如<code>/this|that/</code>, 修改成<code>/th(?:is|at)/</code></p><p>这样做, 可以减少匹配过程中可消除的重复</p><h3 id="减少分支数量缩小范围" tabindex="-1">减少分支数量缩小范围 <a class="header-anchor" href="#减少分支数量缩小范围" aria-label="Permalink to &quot;减少分支数量缩小范围&quot;">​</a></h3><p><code>/red|read/</code>, 可以修改成<code>/rea?d/</code>.此时分支和量词产生的回溯的成本是不一样的.但这样优化后, 可读性会降低的</p>',85)])])}const S=t(P,[["render",k]]);export{R as __pageData,S as default};
