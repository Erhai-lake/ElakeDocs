import{_ as c,c as a,e as d,o}from"./app-Ro_P0HvT.js";const t="/assets/0a609cefd8e5b8b135bc935edb055f7202c27573-CdTGmebG.png",i="/assets/143ca03a620b2fa005bea65a244b8c8c32fb4c2d-DCdRXK6j.png",p="/assets/40e4533d6b68612c8492082b07cd370c68b684c1-DPlmPqLM.png",n="/assets/9b34ff3921b6d2f5d0faa96d1f0448bfb0c78b29-BOWX7D9k.png",b="/assets/08235481de981a8a69d66be2168946e144e1a1b4-CpY4jlAd.png",r="/assets/1e201651d1656969624b975f3911f34a5cdb3942-Brt_ZoUi.png",s="/assets/e5508d6fe2a3d77fdc8f85cf5eddcf54d22dc82a-B8bxhvVy.png",f="/assets/b886745dcfdeb7ff7bb6f4eb803977cac31b3776-lkTHWEMZ.png",l={};function h(g,e){return o(),a("div",null,[...e[0]||(e[0]=[d('<p>如果正则只有精确匹配是没多大意义的, 比如<code>/hello/</code>, 也只能匹配字符串中的<code>hello</code>这个字符串.</p><figure><img src="'+t+'" alt="0a609cefd8e5b8b135bc935edb055f7202c27573" tabindex="0" loading="lazy"><figcaption>0a609cefd8e5b8b135bc935edb055f7202c27573</figcaption></figure><p>正则表达式之所以强大, 是因为其能实现模糊匹配.</p><p>而模糊匹配, 有两个方向上的模糊: 横向模糊和纵向模糊.</p><h2 id="横向模糊匹配" tabindex="-1"><a class="header-anchor" href="#横向模糊匹配"><span>横向模糊匹配</span></a></h2><p>个正则可匹配的字符串的长度不是固定的, 可以有多种可能.</p><p>其实现的方式是使用量词.例如<code>{m,n}</code>, 表示连续出现最少m次, 最多n次.</p><figure><img src="'+i+'" alt="143ca03a620b2fa005bea65a244b8c8c32fb4c2d" tabindex="0" loading="lazy"><figcaption>143ca03a620b2fa005bea65a244b8c8c32fb4c2d</figcaption></figure><h2 id="纵向模糊匹配" tabindex="-1"><a class="header-anchor" href="#纵向模糊匹配"><span>纵向模糊匹配</span></a></h2><p>一个正则匹配的字符串, 具体到某一位字符时, 它可以不是某个确定的字符, 可以有多种可能.</p><p>其实现的方式是使用字符组.例如<code>[abc]</code>, 表示该字符是可以字符<code>a</code>, <code>b</code>, <code>c</code>中的任何一个.</p><figure><img src="'+p+'" alt="40e4533d6b68612c8492082b07cd370c68b684c1" tabindex="0" loading="lazy"><figcaption>40e4533d6b68612c8492082b07cd370c68b684c1</figcaption></figure><h2 id="量词" tabindex="-1"><a class="header-anchor" href="#量词"><span>量词</span></a></h2><p>量词也称重复.掌握<code>{m,n}</code>的准确含义后, 只需要记住一些简写形式.</p><h3 id="常见的简写形式" tabindex="-1"><a class="header-anchor" href="#常见的简写形式"><span>常见的简写形式</span></a></h3><ul><li><p><code>{m,}</code> 表示至少出现<code>m</code>次.</p></li><li><p><code>{m}</code>就是<code>{m,m}</code>.表示出现<code>m</code>次.</p></li><li><p><code>?</code>就是<code>{0,1}</code>.表示出现或者不出现.</p></li><li><p><code>+</code>就是<code>{1,}</code>.表示出现至少一次.</p></li><li><p><code>*</code> 就是<code>{0,}</code>.表示出现任意次, 有可能不出现.</p></li></ul><h3 id="贪婪匹配" tabindex="-1"><a class="header-anchor" href="#贪婪匹配"><span>贪婪匹配</span></a></h3><figure><img src="'+n+'" alt="9b34ff3921b6d2f5d0faa96d1f0448bfb0c78b29" tabindex="0" loading="lazy"><figcaption>9b34ff3921b6d2f5d0faa96d1f0448bfb0c78b29</figcaption></figure><p><code>/\\d{2,5}/</code>表示数字连续出现2到5次.会匹配2位, 3位, 4位, 5位连续数字.</p><p>但是其实贪婪的, 它会尽可能多的匹配.你能给我6个, 我就要6个.你能给我3个, 我就3要个.反正只要在能力范围内, 越多越好.</p><p>我们知道有时贪婪不是一件好事.</p><h3 id="惰性匹配" tabindex="-1"><a class="header-anchor" href="#惰性匹配"><span>惰性匹配</span></a></h3><p>而惰性匹配, 就是尽可能少的匹配.</p><figure><img src="'+b+'" alt="08235481de981a8a69d66be2168946e144e1a1b4" tabindex="0" loading="lazy"><figcaption>08235481de981a8a69d66be2168946e144e1a1b4</figcaption></figure><p><code>/\\d{2,5}?/</code>表示虽然2到5次都行, 当2个就够的时候, 就不在往下尝试了.</p><h2 id="字符组" tabindex="-1"><a class="header-anchor" href="#字符组"><span>字符组</span></a></h2><p>虽叫字符组(字符类), 但只是其中一个字符.例如<code>[abc]</code>, 表示该字符是可以字符<code>a</code>, <code>b</code>, <code>c</code>中的任何一个.</p><h3 id="范围表示法" tabindex="-1"><a class="header-anchor" href="#范围表示法"><span>范围表示法</span></a></h3><p>如果字符组里的字符特别多的话怎么办?可以使用范围表示法.</p><p>比如<code>[123456abcdefGHIJKLM]</code>, 可以写成<code>[1-6a-fG-M]</code>.用连字符<code>-</code>来省略和简写.</p><p>因为连字符有特殊用途, 那么要匹配<code>a</code>, <code>-</code>, <code>z</code>这三者中任意一个字符, 该怎么做呢?</p><p>不能写成<code>[a-z]</code>, 因为其表示小写字符中的任何一个字符.</p><p>可以写成如下的方式:<code>[-az]</code>或<code>[az-]</code>或<code>[a\\-z]</code>.</p><p>即要么放在开头, 要么放在结尾, 要么转义.总之不会让引擎认为是范围表示法就行了.</p><h3 id="排除字符组" tabindex="-1"><a class="header-anchor" href="#排除字符组"><span>排除字符组</span></a></h3><p>纵向模糊匹配, 还有一种情形就是, 某位字符可以是任何东西, 但就不能是<code>a</code>, <code>b</code>, <code>c</code>.</p><p>此时就是排除字符组(反义字符组)的概念.例如<code>[^abc]</code>, 表示是一个除<code>a</code>, <code>b</code>, <code>c</code>之外的任意一个字符.字符组的第一位放<code>^</code>(脱字符), 表示求反的概念.</p><p>当然, 也有相应的范围表示法.</p><h3 id="常见的简写形式-1" tabindex="-1"><a class="header-anchor" href="#常见的简写形式-1"><span>常见的简写形式</span></a></h3><p>有了字符组的概念后, 一些常见的符号我们也就理解了, 因为它们都是系统自带的简写形式.</p><ul><li><code>\\d</code>就是<code>[0-9]</code>.表示是一位数字.</li><li><code>\\D</code>就是<code>[^0-9]</code>.表示除数字外的任意字符.</li><li><code>\\w</code>就是<code>[0-9a-zA-Z_]</code>.表示数字, 大小写字母和下划线.</li><li><code>\\W</code>就是<code>[^0-9a-zA-Z_]</code>.非单词字符.</li><li><code>\\s</code>就是<code>[ \\t\\v\\n\\r\\f]</code>.表示空白符, 包括空格, 水平制表符, 垂直制表符, 换行符, 回车符, 换页符.</li><li><code>\\S</code>就是<code>[^ \\t\\v\\n\\r\\f]</code>. 非空白符.</li><li><code>.</code>就是<code>[^\\n\\r\\u2028\\u2029]</code>.通配符, 表示几乎任意字符.换行符, 回车符, 行分隔符和段分隔符除外.</li></ul><h2 id="多选分支" tabindex="-1"><a class="header-anchor" href="#多选分支"><span>多选分支</span></a></h2><p>一个模式可以实现横向和纵向模糊匹配, 而多选分支可以支持多个子模式任选其一.</p><p>具体形式如下:<code>(p1|p2|p3)</code>, 其中<code>p1</code>, <code>p2</code>, <code>p3</code>是子模式，, 用<code>|</code>(管道符)分隔, 表示其中任何之一.</p><p>例如要匹配<code>aa</code>和<code>bb</code>可以使用<code>/aa|bb/</code>.</p><figure><img src="'+r+'" alt="1e201651d1656969624b975f3911f34a5cdb3942" tabindex="0" loading="lazy"><figcaption>1e201651d1656969624b975f3911f34a5cdb3942</figcaption></figure><p>但有个事实我们应该注意, 比如我用<code>/aa|aabb/</code>, 去匹配<code>aabb</code>字符串时, 结果是<code>aa</code>.</p><figure><img src="'+s+'" alt="e5508d6fe2a3d77fdc8f85cf5eddcf54d22dc82a" tabindex="0" loading="lazy"><figcaption>e5508d6fe2a3d77fdc8f85cf5eddcf54d22dc82a</figcaption></figure><p>而把正则改成<code>/aabb|aa/</code>后.</p><figure><img src="'+f+'" alt="b886745dcfdeb7ff7bb6f4eb803977cac31b3776" tabindex="0" loading="lazy"><figcaption>b886745dcfdeb7ff7bb6f4eb803977cac31b3776</figcaption></figure><p>也就是说, 分支结构也是惰性的, 即当前面的匹配上了, 后面的就不再尝试了.</p>',51)])])}const u=c(l,[["render",h]]),_=JSON.parse('{"path":"/knowledge/tools/regular_expression/fuzzy_matching.html","title":"模糊匹配","lang":"zh-CN","frontmatter":{"title":"模糊匹配","createTime":"2025/12/26 23:11:19","description":"如果正则只有精确匹配是没多大意义的, 比如/hello/, 也只能匹配字符串中的hello这个字符串. 0a609cefd8e5b8b135bc935edb055f7202c275730a609cefd8e5b8b135bc935edb055f7202c27573 正则表达式之所以强大, 是因为其能实现模糊匹配. 而模糊匹配, 有两个方向上的模糊: 横...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"模糊匹配\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-04T07:26:46.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/knowledge/tools/regular_expression/fuzzy_matching.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"模糊匹配"}],["meta",{"property":"og:description","content":"如果正则只有精确匹配是没多大意义的, 比如/hello/, 也只能匹配字符串中的hello这个字符串. 0a609cefd8e5b8b135bc935edb055f7202c275730a609cefd8e5b8b135bc935edb055f7202c27573 正则表达式之所以强大, 是因为其能实现模糊匹配. 而模糊匹配, 有两个方向上的模糊: 横..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-04T07:26:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-04T07:26:46.000Z"}]]},"readingTime":{"minutes":4.01,"words":1203},"git":{"createdTime":1770190006000,"updatedTime":1770190006000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"knowledge/tools/regular_expression/fuzzy_matching.md","headers":[]}');export{u as comp,_ as data};
