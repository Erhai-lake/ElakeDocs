import{_ as a,c as n,e as s,a as t,b as o,d as i,w as c,r as d,o as l}from"./app-D3EIeNJ3.js";const p={};function g(m,e){const r=d("VPLink");return l(),n("div",null,[e[5]||(e[5]=s('<p><strong>模板</strong> 是 <strong>Mock Service</strong> 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析.</p><h2 id="什么是模板字符串" tabindex="-1"><a class="header-anchor" href="#什么是模板字符串"><span>什么是模板字符串?</span></a></h2><p>模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑.</p><h2 id="核心标识符" tabindex="-1"><a class="header-anchor" href="#核心标识符"><span>核心标识符</span></a></h2><p>模板使用了<strong>标识符</strong>机制来区分不同的资源类型:</p><ul><li><strong><code>$</code> (生成器)</strong>: 代表调用一个动态数据生成逻辑. 例如 <code>{{$string.uuid}}</code>.</li><li><strong><code>@</code> (变量)</strong>: 代表引用全局变量系统中的静态或动态存储值. 例如 <code>{{@userName}}</code>.</li><li><strong><code>=</code> (自定义)</strong>: 代表将输入的字符串作为js代码执行, 并返回执行结果. 例如 <code>{{=1+4}}</code>.</li></ul><h3 id="语法结构解析" tabindex="-1"><a class="header-anchor" href="#语法结构解析"><span>语法结构解析</span></a></h3><p>一个典型的模板定义如下:</p><p><code>{{标识符主体(参数)|处理器(参数)}}</code></p><ul><li><strong>双大括号 <code>{{ }}</code></strong>: 模板的边界标识符.</li><li><strong>分类与定位</strong>: <ul><li><strong>生成器</strong>: 使用 <code>{{$分类ID.生成器ID(参数)}}</code>.</li><li><strong>变量</strong>: 使用 <code>{{@变量名}}</code>.</li><li><strong>自定义</strong>: 使用 <code>{{=js代码}}</code>.</li></ul></li><li><strong>处理链 <code>|</code></strong>: 初始值(无论是生成的还是取值的)会沿着管道依次传递给处理器进行二次加工.</li><li><strong>参数传递 <code>()</code></strong>: <ul><li><strong>对象参数</strong>: 使用 <code>{key=value}</code> 形式. 例如 <code>({length=10,type=&quot;hex&quot;})</code>.</li><li><strong>简单参数</strong>: 如果方法只需一个参数, 可直接简写. 例如 <code>(114514)</code>.</li><li><strong>赋值符</strong>: 参数内部统一使用 <code>=</code> 进行赋值, 多个参数间用 <code>,</code> 分隔.</li></ul></li></ul><h2 id="变量系统" tabindex="-1"><a class="header-anchor" href="#变量系统"><span>变量系统</span></a></h2><p>于 [0.0.3] 版本引入.</p><p>变量系统允许你在 Mock 过程中实现数据的跨区域共享与持久化.</p><h3 id="变量的引用与处理" tabindex="-1"><a class="header-anchor" href="#变量的引用与处理"><span>变量的引用与处理</span></a></h3><p>你可以直接通过 <code>@</code> 符号访问存储在 <strong>mockService</strong> 中的变量, 并且变量同样支持使用处理器:</p><p><code>{{@orderId|upper}}</code></p><blockquote><p><strong>注意</strong>: 由于变量不属于特定的生成器分类, 变量所使用的处理器将会在<strong>全局处理器池</strong>中进行全域搜索.</p></blockquote><h2 id="进阶特性" tabindex="-1"><a class="header-anchor" href="#进阶特性"><span>进阶特性</span></a></h2><h3 id="递归嵌套" tabindex="-1"><a class="header-anchor" href="#递归嵌套"><span>递归嵌套</span></a></h3><p>模板支持<strong>深度嵌套</strong>. 你可以在一个模板的参数位置, 嵌入另一个完整的模板. 解析器会从最内层开始递归执行, 实现极具灵活性的组合.</p><blockquote><p><strong>示例概念</strong>: <code>{{$string.uuid|concat(&quot;{{$string.uuid}})&quot;)}}</code></p><p>先生成一个uuid, 随后在生成一个uuid, 最后将这两个字符串拼接起来.</p></blockquote>',21)),t("p",null,[e[1]||(e[1]=o("只需要了解概念, 模板不需要手动硬背, 我们提供了 ",-1)),i(r,{href:"./generate_template"},{default:c(()=>[...e[0]||(e[0]=[t("code",null,"generateTemplate",-1)])]),_:1}),e[2]||(e[2]=o(" 方法来辅助你生成",-1)),e[3]||(e[3]=t("code",null,"$",-1)),e[4]||(e[4]=o("类型的模板字符串的喵~",-1))])])}const h=a(p,[["render",g]]),k=JSON.parse('{"path":"/project/mock_service/template/template.html","title":"模板字符串","lang":"zh-CN","frontmatter":{"title":"模板字符串","createTime":"2026/02/06 18:17:19","description":"模板 是 Mock Service 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析. 什么是模板字符串? 模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑. 核心标识符 模板使用了标识符机制来区分不同的资源类型: $ (生成器): 代表调用一个动态数据生成逻辑. 例如 {{$string.uui...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"模板字符串\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-12T16:00:54.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.elake.top/project/mock_service/template/template.html"}],["meta",{"property":"og:site_name","content":"洱海文档"}],["meta",{"property":"og:title","content":"模板字符串"}],["meta",{"property":"og:description","content":"模板 是 Mock Service 的灵魂. 整个库的架构设计, 本质上都是为了支撑模板的高效生成与精准解析. 什么是模板字符串? 模板字符串是一种声明式的语法, 允许你通过简单的文本描述来构建复杂的数据生成逻辑. 核心标识符 模板使用了标识符机制来区分不同的资源类型: $ (生成器): 代表调用一个动态数据生成逻辑. 例如 {{$string.uui..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-12T16:00:54.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-12T16:00:54.000Z"}]]},"readingTime":{"minutes":2.19,"words":657},"git":{"createdTime":1770539937000,"updatedTime":1770912054000,"contributors":[{"name":"Erhai-lake","username":"Erhai-lake","email":"erhai.lake.0714@gmail.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Erhai-lake?v=4","url":"https://github.com/Erhai-lake"}]},"autoDesc":true,"filePathRelative":"project/mock_service/template/template.md","headers":[]}');export{h as comp,k as data};
